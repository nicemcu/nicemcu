<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>NUC980 Linux 笔记</title>
      <link href="/2021/08/02/NUC980Note/"/>
      <url>/2021/08/02/NUC980Note/</url>
      
        <content type="html"><![CDATA[<p>N年前折腾过NUC972，可惜需要配个头又大管脚又多的Nand flash，后来它的弟弟NUC980诞生了，支持了QSPI Nand，但阉割掉了LCD控制器，也无所谓了，如果需要耍屏的话还可以其他方案了，全志的V3S、国产的SSD20x都是屏驱的好方案。赶着JLC支持免费的紫油及免费的4层PCB打样，就继续去薅他的羊毛~</p><p><img src="../../../../medias/boardPic/2021/tools/NUC980Board.jpg" alt="MyNUC980 Board"></p><p>调试的过程中也是遇坑无数，满眼都是泪…  比如uboot下以太网，不知道你们是否都能正常tftp，反正我是折腾了好久，对照着nuc972的网卡驱动改过来的，目前uboot下网络能正常运行，但是启动linux后，网络死活跑不起来，而另一块不是核心板的板子，同样的固件、同样的配置，网络跑的很欢快，丢包还是有的。真是无语了~</p><h3 id="烧写地址配置"><a href="#烧写地址配置" class="headerlink" title="烧写地址配置"></a>烧写地址配置</h3><p>Nuvoton NuWriter 下载、安装，选择SPI NAND</p><table><thead><tr><th align="center">名称</th><th align="center">类型</th><th align="center">execute地址</th><th align="center">offset</th></tr></thead><tbody><tr><td align="center">SPL</td><td align="center">Loader</td><td align="center">200</td><td align="center">0</td></tr><tr><td align="center">uboot</td><td align="center">Data</td><td align="center"></td><td align="center">0x10000</td></tr><tr><td align="center">env</td><td align="center">Environment</td><td align="center"></td><td align="center">0x8000</td></tr><tr><td align="center">kernel(uImage)</td><td align="center">Data</td><td align="center"></td><td align="center">0x20000</td></tr><tr><td align="center">rootfs</td><td align="center">Data</td><td align="center"></td><td align="center">0x160000</td></tr></tbody></table><h3 id="Uboot"><a href="#Uboot" class="headerlink" title="Uboot"></a>Uboot</h3><ol><li><p>env的配置：（放txt里直接烧录到指定位置即可）<br>setenv ethaddr 08:55:00:11:66:88<br>setenv ipaddr 192.168.2.28<br>setenv serverip 192.168.2.21<br>setenv bootcmd sf probe 0 75000000;sf read 0x7fc0 0x200000 0x800000;bootm 0x7fc0<br>saveenv</p></li><li><p>uboot tftp启动内核：（windows下开tftp软件，配置目录，关闭防火墙）<br> tftpboot 0x7fc0 980uimage<br> bootm 0x7fc0</p></li></ol><h3 id="内核"><a href="#内核" class="headerlink" title="内核"></a>内核</h3><ol><li><strong>取消ramfs文件系统</strong>，真是坑爹的骚操作。并配置：<br>noinitrd root=/dev/mtdblock2 rootfstype=yaffs2 rootflags=inband-tags rw console=ttyS0,115200n8 init=/sbin/init mem=64M rootwait=1 mtdparts=nand0:0x200000@0x0(u-boot),0x1400000@0x200000(kernel),-(user)</li><li>配置SPI时，取消quard模式，选择normal模式，奇葩的设置。</li><li>使能NFS文件系统。</li></ol><h3 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h3><ol><li>官方提供的文件系统傻傻的，命令弱的可怜，自己动手丰衣足食，使用busybox配置做文件系统即可，注意编译的时候不要选择static。可参考如下连接制作：<br><a href="https://blog.csdn.net/weixin_38387929/article/details/108538631" target="_blank" rel="noopener">https://blog.csdn.net/weixin_38387929/article/details/108538631</a></li><li>生成busybox文件后，查看所依赖的库文件（没必要copy全部的库，太多太大了）<br>arm-linux-gnueabi-readelf -d busybox | grep NEEDED<br>或者：arm-linux-gnueabi-objdump -x busybox | grep NEEDED<br>将其所需要的库文件拷贝到根目录的lib文件下即可。注意有很多是连接文件，需要连同实际文件一起copy。一般只需要4个即可。</li><li>挂在NFS文件系统：<br>mount -t nfs -o intr,nolock,tcp,rsize=2048,wsize=1024 192.168.2.21:/ /mnt/nfs</li><li>busybox 显示用户名及路径：参考如下连接<br><a href="https://blog.csdn.net/litao31415/article/details/50188243" target="_blank" rel="noopener">https://blog.csdn.net/litao31415/article/details/50188243</a></li><li>网络调试工具：<strong>ethtool</strong>，新塘提供了，直接make即可，通过它可以看当前的网卡配置。貌似还有个mii-tool的工具，没用过。Linux网络命令mii-tool和ethtool使用参考连接：<br><a href="https://blog.csdn.net/yzhang6_10/article/details/81557195" target="_blank" rel="noopener">https://blog.csdn.net/yzhang6_10/article/details/81557195</a></li></ol><h3 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h3><ol><li>win10 WSL下cannot execute binary file: Exec format error:  - 安装QEMU<br>sudo apt update<br>sudo apt install qemu-user-static<br>sudo update-binfmts –install i386 /usr/bin/qemu-i386-static –magic ‘\x7fELF\x01\x01\x01\x03\x00\x00\x00\x00\x00\x00\x00\x00\x03\x00\x03\x00\x01\x00\x00\x00’ –mask ‘\xff\xff\xff\xff\xff\xff\xff\xfc\xff\xff\xff\xff\xff\xff\xff\xff\xf8\xff\xff\xff\xff\xff\xff\xff’<br>sudo service binfmt-support start</li></ol>]]></content>
      
      
      <categories>
          
          <category> MCU </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nuvoton </tag>
            
            <tag> ARM9 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CH573F调试笔记 二 之编译调试与下载</title>
      <link href="/2021/07/28/CH573F02Debug/"/>
      <url>/2021/07/28/CH573F02Debug/</url>
      
        <content type="html"><![CDATA[<p>工欲善其事，必先利其器！快捷的仿真调试会事半功倍，反之则事倍功半。先给这个小板配个底板，把要调试的功能都引出来先。顺便喷一下boot上的那个小按键：太小太不方便按了，于是在上面的boot脚上焊了个大点的四脚按键，按起来有感觉多了~</p><p><img src="../../../../medias/boardPic/2021/tools/Ch573Base.jpg" alt="CH573F底板"></p><p>CH573虽支持2线调试，可惜不支持JLink，自然也不支持JLink全家桶，官方提供的下载器以及ISP工具虽然能用，但是不好用，于是先从打造好用的下载工具开始~</p><p>感谢沁恒的FAE提供了ISP下载的参考例程，基于提供的lib文件，用QT做了个简洁的下载工具，简洁而不简单~</p><p><img src="../../../../medias/boardPic/2021/tools/MyWCHISP.png" alt="MyWCHISP"></p><p>主要实现如下功能：</p><ol><li>选择待烧写的BIN文件。（如何生成BIN文件请参考上一篇）</li><li>检测CH573F是否进入USB ISP模式，进入则连接。</li><li>连接成功后则自动烧写（可勾选选择是否自动烧写）</li><li>烧写成功后自动复位运行app。</li></ol><p>CH573F自带的bootloader只支持冷启动，即上电时检测到boot脚被按下后会运行boot，如果通过RST脚复位后也不识别，所以如果要每次要操作的时候就得不断上下电还要按住boot键。好在发现了这篇文档：</p><p>从应用跳到芯片Boot的方法：<a href="https://www.cnblogs.com/iot-fan/p/14344779.html" target="_blank" rel="noopener">https://www.cnblogs.com/iot-fan/p/14344779.html</a></p><p>于是将其copy进工程，通过解析串口指令“enisp”自动进入bootloader并执行烧写，烧写成功后又自动运行。终于可以摆脱硬件在不断电的情况下自动完成了。</p><p>需要该软件的小伙伴可联系我获取~</p>]]></content>
      
      
      <categories>
          
          <category> MCU </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BLE </tag>
            
            <tag> RISC-V </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CH573F调试笔记 一 之初尝</title>
      <link href="/2021/07/21/CH573F01Start/"/>
      <url>/2021/07/21/CH573F01Start/</url>
      
        <content type="html"><![CDATA[<p>最近需要一款低成本的蓝牙芯片，KT6368A是不错的选择，但需外配MCU，需要一款能像NRF52840那样带USB的蓝牙SOC，价格又要美美的，于是就找到了它：<strong>CH573F</strong> ！官方资源开放的连PCB的源文件都提供了，刚好某创和某配都提供了免费PCB打样，赶紧去薅了一把羊毛，PCB文件直接拿去打样，在此非常感谢沁恒市场经理李先生，不仅提供了CH573F和CH569的样片，还提供了一个烧写器用于调试，真是太贴心了~</p><p><img src="../../../../medias/boardPic/2021/tools/CH573Board.jpg" alt="CH573F BLEBoard Pic"></p><h3 id="CH573F"><a href="#CH573F" class="headerlink" title="CH573F"></a>CH573F</h3><ul><li>32位RISC处理器WCH RISC-V3A</li><li>支持RV32 IMAC指令集，支持<strong>单周期乘法和硬件除法</strong></li><li>内置<strong>18K SRAM，512K Flash</strong> ROM，支持ICP、ISP和IAP，支持OTA无线升级</li><li>集成2.4GHz RF收发器和基带及链路控制，提高优化的协议栈和应用层API，支持组网</li><li>内置USB控制器和USB收发器，支持USB2.0全速和低速主机或设备</li><li>多种低功耗模式：Idle，Halt, Sleep, Shutdown, 内置电池电压低压监控，最低睡眠电流0.3uA</li><li>内置AES-128加解密单元，芯片唯一ID</li><li>其他传统接口：UARTx4、SPI、12位ADC、8通道触摸按键等。</li></ul><p>主频不详？！貌似只有20MHz？32MHz的主晶振时钟输入，不明白为何主频这么低。先不管了，谁让它这么便宜呢~ （ 看程序主频应该最高<strong>60MHz</strong>）顺便上一张沁恒的BLE选型：<br><img src="../../../../medias/boardPic/2021/tools/CHBLE.png" alt="CH BLE 选型"></p><h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><ol><li>先从官网下载所需资源：<a href="http://www.wch.cn/products/CH573.html" target="_blank" rel="noopener">http://www.wch.cn/products/CH573.html</a><br>Datasheet：CH573DS1.PDF<br>CH573评估板说明及参考应用例程：CH573EVT.ZIP<br>集成开发环境(IDE)：MounRiver Studio(MRS)<br>CH573F板载天线核心板：CH573PCB.ZIP<br>系统平台低功耗蓝牙开发接口库：WCHBleLib_MultiOS.ZIP<br>沁恒芯云物联平台说明及参考应用例程：WCHIOT.ZIP<br>单片机系列芯片程序烧录软件：WCHISPTool_Setup.exe</li><li>开发环境只能用官方提供的MounRiver Studio，看介绍也支持JLink，慢慢熟悉之。</li></ol><h3 id="埋坑笔记-HW"><a href="#埋坑笔记-HW" class="headerlink" title="埋坑笔记 - HW"></a>埋坑笔记 - HW</h3><ol><li>芯片背面的焊盘要接地！芯片背面的焊盘要接地！芯片背面的焊盘要接地！整个芯片的地只有芯片背面的焊盘，所以必须要可靠接地！对于DIY者来说不够友好，焊之前处理下也能搞定。</li><li>电感L1是22uH电感，0805封装的，这个封装以及32K RTC晶振的封装、0603封装的LED、0402的某几个电容都很蛋疼，翻箱倒柜找好物料然后开焊。</li><li>芯片的仿真引脚：PB14-TIO-SWDIO，PB15-TCK-SWCLK，默认boot PIN：PB22</li><li>两线仿真调试接口通过ISP工具配置，仿真调试接口启用后，PB15和PB14仅用作TCK和TIO，不再用于GPIO或外设复用功能引脚。如需复用，需关闭仿真调试接口功能。<br><img src="../../../../medias/boardPic/2021/tools/CHusrCfg.png" alt="用户配置信息"></li><li>系统SysTick定时器：64位，递减型计数器，支持HCLK或HCLK/8作为时基，具有较高优先级。</li><li>上电后默认不启用DC-DC，而是提供直通电源，为了降低正常运行时的系统功耗，可以选择<strong>启用DC-DC提升电源能耗利用率</strong>，工作电流通常会下降到直通方式的<strong>60%</strong>左右。</li><li>USB Device模式下，有0、1、2、3、4、共5组双向端点，最大数据包长64字节。<ul><li>断点0是默认断点，发送和接收共用64字节数据缓冲区。</li><li>端点1、2、3各自包含一个发送端点IN和一个接收端点OUT，发送和接收各有一个独立的64字节或者<strong>双64字节</strong>数据缓冲区，支持批量、中断和实时/同步传输。</li><li>端点4包括一个发送端点IN和一个接收端点OUT，发送和接收各有一个独立的64字节数据缓冲区，支持批量、中断和实时/同步传输。</li></ul></li><li>USB总线上的上拉电阻可以由软件随时设置是否启用。当R8_USB_CTRL中的RB_UC_DEV_PU_EN置1时，在内部位USB总线的DP/DM引脚连接上拉电阻，并启用USB设备功能。</li></ol><h3 id="埋坑笔记-SW"><a href="#埋坑笔记-SW" class="headerlink" title="埋坑笔记 - SW"></a>埋坑笔记 - SW</h3><p>硬件手册基本上粗略看完一遍，接下来开始折腾软件。</p><ol><li>首先安装WCHISPTool_Setup.exe，按住Boot按键上电，如下图示，确认能识别出CH573F的设备，选择开启仿真。<br><img src="../../../../medias/boardPic/2021/tools/WCHISP.png" alt="CH573F ISP"></li><li>安装MounRiver Studio，解压CH573EVT.ZIP，然后导入一个USB的例程 ..\USB\Device\CompoundDev\CompoundDev.wvproj，貌似是一个USB HID的复合设备，导入成功后CTRL+B编译，只要没有其他误操作，这个过程基本上都会编译成功的，在obj目录下会有编译出的CompoundDev.hex文件，重复上一步的操作，按住Boot进USB ISP模式，通过WCHISPTool将该文件下载进去，重启后查看设备管理器，人体学输入设备中会多出两个USB输入设备。</li><li>测试蓝牙工程，BLE目录下有25个例程，真丰富，选择其中HID KeyBoard测试，导入..\BLE\HID_Keyboard\HID_Keyboard.wvproj，编译之。重复ISP的步骤，将生成的HID_Keyboard.hex文件烧入其中，打开手机蓝牙搜寻设备，会出现HID Keybrod的蓝牙设备，连接后提示配置实体键盘。打开手机App便签，然后就会每隔一秒钟收到一个字符，从abcdef ~ xyz。</li><li>BLE目录下的文档 <strong>沁恒低功耗蓝牙软件开发参考手册.pdf</strong> ，搞蓝牙的话还是需要好好看看的。</li><li>配置MounRiver Studio，生成BIN文件：（Help文件中有描述）<ul><li>右键工程配置选项 - &gt; C/C++ Build - &gt; Settings , 切换至 Build Steps标签页，在下面的 Post-build steps中输入如下命令：</li><li>“${eclipse_home}\toolchain\RISC-V Embedded GCC\bin\riscv-none-embed-objcopy”  -O binary “${ProjName}.elf”  “..\${ProjName}.bin”</li><li>或者直接在GNU RISC-V Cross Greate Flash Image选项中，选择Output file format <strong>Raw binary</strong>即可。<br>不知为何，我这边使用MounRiver Studio，Ctrl+B编译 很慢很慢的，make -j4或-j8都一样的慢。</li></ul></li><li>博客园中有非常好的笔记，满满的干货，在此记录并感谢之~<br><a href="https://www.cnblogs.com/iot-fan/tag/CH57x/" target="_blank" rel="noopener">https://www.cnblogs.com/iot-fan/tag/CH57x/</a><br>TMOS系统介绍：<a href="https://www.cnblogs.com/iot-fan/p/13460082.html" target="_blank" rel="noopener">https://www.cnblogs.com/iot-fan/p/13460082.html</a><br>用户Boot和App：<a href="https://www.cnblogs.com/iot-fan/p/14976335.html" target="_blank" rel="noopener">https://www.cnblogs.com/iot-fan/p/14976335.html</a><br>从应用跳到芯片Boot的方法：<a href="https://www.cnblogs.com/iot-fan/p/14344779.html" target="_blank" rel="noopener">https://www.cnblogs.com/iot-fan/p/14344779.html</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> MCU </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BLE </tag>
            
            <tag> RISC-V </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>不正经的PCB板</title>
      <link href="/2021/05/21/PCBCard/"/>
      <url>/2021/05/21/PCBCard/</url>
      
        <content type="html"><![CDATA[<p>自从JLC将PCB打样费降至5元/款，JP跟进免费打样，可乐坏我和我的小伙伴了，每个月不打上几款感觉亏了几个亿。而同时又带来了新的苦恼：<strong>免费打样券用不完肿么办？</strong>于是PCB打板开始不正经起来~ </p><ol><li><p>PCB可以做结构支撑<br><img src="../../../../medias/boardPic/2021/pcb/jiegou.jpg" alt="MyGUIBoard"></p></li><li><p>PCB可以做日历显示（还没来得及焊接，芯片涨价涨的玩不起了…）<br><img src="../../../../medias/boardPic/2021/pcb/rili.jpg" alt="MyGUIBoard"></p></li><li><p>PCB板可以做名片：（擦掉部分信息）<br><img src="../../../../medias/boardPic/2021/pcb/mingpian.jpg" alt="MyMingPian"></p></li><li><p>PCB可以做霸气的挪车牌：（刺客五六七的飞镖）<br><img src="../../../../medias/boardPic/2021/pcb/feibiao.jpg" alt="FeiBiaoNuoChe"></p></li><li><p>PCB可以做太极图<br><img src="../../../../medias/boardPic/2021/pcb/taiji.jpg" alt="TaiJi"></p></li><li><p>PCB可以做杯垫<br><img src="../../../../medias/boardPic/2021/pcb/beidian.jpg" alt="BeiDian"></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> PCB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PCB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>KT6368A - 8脚的蓝牙BLE</title>
      <link href="/2021/04/13/KT6368A/"/>
      <url>/2021/04/13/KT6368A/</url>
      
        <content type="html"><![CDATA[<p>偶然间见到了这款神芯：KT6368A，8脚的蓝牙UART透传芯片，淘宝零售价1.6元/pcs，禁不住赶紧做板一试。<br><img src="../../../../medias/boardPic/2021/tools/KT6368A.jpg" alt="KT6368A BLE Pic"></p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>KT6368A芯片是一款支持蓝牙双模的纯数据芯片，蓝牙5.1版本。芯片的亮点在超小尺寸，超级价格。以及简单明了的透传和串口AT控制功能。大大降低了嵌入蓝牙在其它产品的开发难度和成本。<br>同时支持<strong>SPP</strong>和<strong>BLE</strong> 。但是只能任选其中一个协议使用。<br>备注：这款芯片最大的特点，就是成本低，使用简单，生产简单。无他。</p><p>电流：芯片上电启动是20mA，马上进入低功耗广播20uA和唤醒4mA交替。连接成功就一直都是4mA。<br>电路：简洁的令人发指！如果能把晶振内置，再多引出2个IO那简直太完美了！<br>串口：波特率默认115200.<br>PIN2：连接状态指示。连接成功后输出高电平，未连接为高阻态。 – <strong>这脚如果能配置成发送完成状态指示就好了，不然咋知道发送是否完成？</strong></p><h3 id="AT指令"><a href="#AT指令" class="headerlink" title="AT指令"></a>AT指令</h3><ol><li><p>指令格式：AT+CMD[parama]\r\n<br>&lt;IND&gt; : 数据反馈是蓝牙把各种状态和数据信息反馈给主机，以<strong>&lt;IND&gt;</strong>作为开头<br>CMD指令：</p><table><thead><tr><th align="center">CMD</th><th align="center">功能描述</th></tr></thead><tbody><tr><td align="center">AT+CT</td><td align="center">设置波特率，如AT+CT01\r\n</td></tr><tr><td align="center">AT+CZ</td><td align="center">芯片复位</td></tr><tr><td align="center">AT+CW</td><td align="center">芯片恢复出厂设置</td></tr><tr><td align="center">AT+CL</td><td align="center">芯片低功耗设置</td></tr><tr><td align="center">AT+BM</td><td align="center">设置BLE蓝牙名称，如AT+BMMyBle\r\n</td></tr><tr><td align="center">AT+BN</td><td align="center">设置BLE的MAC地址</td></tr><tr><td align="center">AT+BD</td><td align="center">设置SPP蓝牙名称</td></tr><tr><td align="center">AT+BS</td><td align="center">设置BLE连接密码，此功能没有实现</td></tr><tr><td align="center">–</td><td align="center">–</td></tr><tr><td align="center">AT+QT</td><td align="center">查询系统的波特率</td></tr><tr><td align="center">AT+QL</td><td align="center">查询系统的低功耗状态</td></tr><tr><td align="center">AT+TM</td><td align="center">查询BLE蓝牙名称</td></tr><tr><td align="center">AT+TN</td><td align="center">查询BLE蓝牙地址</td></tr><tr><td align="center">AT+TN</td><td align="center">查询SPP蓝牙名称</td></tr><tr><td align="center">AT+TS</td><td align="center">查询BLE蓝牙连接密码,功能保留</td></tr><tr><td align="center">–</td><td align="center">–</td></tr><tr><td align="center">AT+B401\r\n</td><td align="center">开启BLE功能，AT+B400\r\n关闭该功能</td></tr><tr><td align="center">AT+B501\r\n</td><td align="center">开启SPP功能，AT+B500\r\n关闭该功能</td></tr><tr><td align="center">AT+T4\r\n</td><td align="center">查询BLE功能是否打开，芯片返回T4+01或T4+00</td></tr><tr><td align="center">AT+T5\r\n</td><td align="center">查询SPP功能是否打开，芯片返回T5+01或T5+00</td></tr></tbody></table></li><li><p>设置波特率：AT+CT01\r\n=9600;     05=115200;    07=512000;    10=1000000;     还支持其他的一些波特率设置，请参考手册。</p></li><li><p>关闭BLE或SPP功能后，必须重新上电，此功能才能生效。</p></li><li><p>芯片返回错误信息表：</p><table><thead><tr><th align="center">错误信息</th><th align="center">功能描述</th></tr></thead><tbody><tr><td align="center">ER+1\r\n</td><td align="center">接收的数据帧不对</td></tr><tr><td align="center">ER+2\r\n</td><td align="center">接收的命令不存在，如发送的AT+KK字符串不正确</td></tr><tr><td align="center">ER+3\r\n</td><td align="center">接收的AT指令，没有收到回车换行，\r\n</td></tr><tr><td align="center">ER+4\r\n</td><td align="center">发送的指令给的参数超范围了</td></tr><tr><td align="center">ER+(5,6,8)\r\n</td><td align="center">保留</td></tr><tr><td align="center">ER+7\r\n</td><td align="center">在BLE连接成功状态下，发送数据给手机，手机端未打开notify</td></tr></tbody></table></li></ol><h3 id="BLE透传"><a href="#BLE透传" class="headerlink" title="BLE透传"></a>BLE透传</h3><ol><li>目前支持BLE纯数传，BLE和SPP均只能作为从，也就是“SERVER”端。</li><li><strong>一旦蓝牙被连接之后，芯片自动进入透传模式。不再识别AT指令</strong>。</li><li>单次吞吐的数据最大是<strong>1024</strong>字节，支持16位或128位的UUID。128位的需要特别定制。</li><li>BLE的UUID说明：<br>4.1    ：    主UUID是“<strong>FFF0</strong>”<br>4.2    ：    特征1的UUID是“<strong>FFF1</strong>”，特征是“<strong>WRITE</strong>” “<strong>NOTIFY</strong>”<br>4.3    ：    特征2的UUID是“<strong>FFF2</strong>”，特征是“<strong>WRITE</strong>” “<strong>NOTIFY</strong>”<br>4.4    ：    特征3的UUID是“<strong>FFF3</strong>”，特征是“<strong>WRITE</strong>” </li></ol><h3 id="SPP透传"><a href="#SPP透传" class="headerlink" title="SPP透传"></a>SPP透传</h3><ol><li>SPP走的是经典蓝牙2.1的协议，不推荐使用，新产品建议使用BLE。</li><li>单次吞吐的数据最大是<strong>1024</strong>字节。</li><li>SPP是经典蓝牙里面的一个子链路。</li><li>SPP数传和BLE是互斥的，如果用SPP请关闭BLE。</li></ol><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><ol><li>发送AT+TM\r\n，查询当前BLE名称。</li><li>发送AT+BMMyBle\r\n，设置BLE名称为MyBle，收到OK响应。</li><li>发送AT+CZ\r\n，让芯片复位并重启，然后继续查询蓝牙名称，看是否是MyBle。</li><li>发送AT+T4\r\n和AT+T5\r\n，查询BLE和SPP的打开情况，结果都是打开的状态。</li><li>发送AT+B500\r\n关闭SPP功能，只保留BLE功能。</li><li>打开手机蓝牙，扫描设备，居然查找到的蓝牙为MyBle\r\n，说明执行AT+BM时出错，重新发送<strong>AT+BMMyBle</strong>，返回OK。</li><li>手机安装LightBlue Explorer APK进行测试。找到MyBle连接之，可以看到信号强度。<br><img src="../../../../medias/boardPic/2021/tools/phone.png" alt="LightBlue Explorer Pic"></li><li>串口调试记录：收发都比较简单，手机端是二进制显示，所有要发送1234需要发送0x31323334才行。<br><img src="../../../../medias/boardPic/2021/tools/serialDebug.png" alt="串口调试Pic"></li></ol><p>操作很简单，没有任何流控，发送后也不清楚发送成功了没，什么时候可以再发送也不清楚，自个写程序管理吧。有此神芯，仍无法如虎添翼啊…<br><img src="../../../../medias/boardPic/2021/tools/tiger.jpg" alt="TIGER Pic"></p>]]></content>
      
      
      <categories>
          
          <category> MCU </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BLE </tag>
            
            <tag> KT6368A </tag>
            
            <tag> 蓝牙 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GD32E505 SPI Flash</title>
      <link href="/2021/04/12/GD32E50x05SpiFlash/"/>
      <url>/2021/04/12/GD32E50x05SpiFlash/</url>
      
        <content type="html"><![CDATA[<p>GD32E50x有专用的SQPI外设，支持接SQPI接口的PSRAM、Flash等，不过LQFP64封装的不支持，这些管脚都分配到了PF口或PG口上。好在SPI0且仅有SPI0支持4线模式，可以尝试四线接口的SPI Flash。</p><h3 id="GD32E505-SPI0四线操作模式："><a href="#GD32E505-SPI0四线操作模式：" class="headerlink" title="GD32E505 SPI0四线操作模式："></a>GD32E505 SPI0四线操作模式：</h3><p>SPI四线模式用于控制四线SPI flash外设。要配置成SPI四线模式，首先要确认<strong>TBE</strong>位置1，且<strong>TRANS</strong>位清零，然后将SPI_QCTL寄存器中的<strong>QMOD</strong>位置1。在SPI 四线模式，SPI_CTL0寄存器中BDEN位、BDOEN位、CRCEN位、CRCNT位、FF16位、RO位和LF位保持清零，且MSTMOD位置1，以保证SPI工作于主机模式。SPIEN位、PSC位、CKPL位和CKPH位根据需要进行配置。 </p><p>SPI四线模式有两种运行模式：<strong>四线写模式</strong>和<strong>四线读模式</strong>，通过SPI_QCTL寄存器中的QRD位进行配置。 </p><h3 id="四线写模式"><a href="#四线写模式" class="headerlink" title="四线写模式"></a>四线写模式</h3><p>当SPI_QCTL寄存器中的QMOD位置1且QRD位清零时，SPI工作在四路写模式。在四路写模式中，MOSI、MISO、IO2 和IO3 都用作输出引脚。在SCK产生时钟信号后，一旦数据写入SPI_DATA寄存器（TBE位清零）且SPIEN位置1时，SPI将会通过这四个引脚发送写入的数据。一旦SPI开始数据传输，它总是在数据帧结束时检查TBE标志位的状态，若不能满足条件则停止传输。 </p><p>四路模式下发送操作流程： </p><ol><li>根据应用需求，配置SPI_CTL0和SPI_CTL1中的时钟预分频、时钟极性、相位等参数； </li><li>将SPI_QCTL中的QMOD位置1，然后将SPI_CTL0中的SPIEN位置1来使能SPI功能； </li><li>向SPI_DATA寄存器中写入一个字节的数据，TBE标志位将会清零； </li><li>等待硬件将TBE位重新置位，然后写入下一个字节数据。<br><img src="../../../../medias/boardPic/2021/tools/QSPIWrite.png" alt="四线SPI写时序 Pic"></li></ol><h3 id="四线写模式-1"><a href="#四线写模式-1" class="headerlink" title="四线写模式"></a>四线写模式</h3><p>当SPI_QCTL寄存器中的QMOD位和QRD位都置1时，SPI工作在四路读模式。在四路读模式中，MOSI、MISO、IO2 和IO3都用作输入引脚。当数据写入SPI_DATA寄存器（此时TBE位被清零）且SPIEN位置1时，SPI开始在SCK信号线上产生时钟信号。写数据到SPI_DATA寄存器只是为了产生SCK时钟信号，所以可以写入任何数据。SPI开始数据传输之后，每发送一个数据帧都要检测SPIEN位和TBE位，若条件不满足则停止传输。所以软件需要一直向SPI_DATA写空闲数据，以产生SCK时钟信号。 </p><p>四路模式下接收操作流程： </p><ol><li>根据应用需求，配置SPI_CTL0和SPI_CTL1中时钟预分频、时钟极性、相位等参数； </li><li>将SPI_QCTL中的QMOD位和QRD位置1，然后将SPI_CTL0中的SPIEN位置1来使能SPI功能； </li><li>写任意数据（例如0xFF）到SPI_DATA寄存器； </li><li>等待RBNE位置1，然后读SPI_DATA寄存器来获取接收的数据； </li><li>写任意数据（例如0xFF）到SPI_DATA寄存器，以接收下一个字节数据。<br><img src="../../../../medias/boardPic/2021/tools/QSPIRead.png" alt="四线SPI读时序 Pic"></li></ol><h3 id="SPI停止流程"><a href="#SPI停止流程" class="headerlink" title="SPI停止流程"></a>SPI停止流程</h3><p>不同运行模式下采用不同的流程来停止SPI功能。<br><strong>SPI四路模式</strong> ：在禁用SPI四路模式或者关闭SPI功能之前，软件应该先检查：TBE位置1，TRANS位清零，SPI_QCTL中的QMOD位和SPI_CTL0中的SPIEN位清零。 </p><h3 id="例程分析"><a href="#例程分析" class="headerlink" title="例程分析"></a>例程分析</h3><p>木有例程。。。只能自个啃啃试试了，如果不行，就换成2线的跟普通SPI Flash操作流程一样就完事了。</p>]]></content>
      
      
      <categories>
          
          <category> MCU </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GD32E505 </tag>
            
            <tag> CortexM33 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GD32E505 Flash 操作</title>
      <link href="/2021/04/12/GD32E50x04Flash/"/>
      <url>/2021/04/12/GD32E50x04Flash/</url>
      
        <content type="html"><![CDATA[<h3 id="GD32E505-Flash："><a href="#GD32E505-Flash：" class="headerlink" title="GD32E505 Flash："></a>GD32E505 Flash：</h3><ol><li><p>设备唯一ID（UNIQUE ID ,96bit，只能按字32位访问），基地址：0x1FFF_F7E8</p></li><li><p>闪存的前512K字节空间内，CPU执行指令需要0~4个等待时间。</p></li><li><p>闪存页大小为<strong>8KB</strong>，支持32位字/16位半字编程，页擦除和整片擦除。</p></li><li><p>2K字节 OTP块（一次性编程），用于存储用户数据。</p></li><li><p>16字节的选项字节，根据用户需求配置，当系统复位时，选项字节被加载到选项字节控制寄存器。</p></li><li><p>GD32E505_CL闪存基地址和构成：</p><table><thead><tr><th align="center">闪存</th><th align="center">名称</th><th align="center">地址范围</th><th align="center">大小</th></tr></thead><tbody><tr><td align="center">主闪存</td><td align="center">Page0</td><td align="center">0x0800_0000~0x0800_1FFF</td><td align="center">8KB</td></tr><tr><td align="center">主闪存</td><td align="center">Page1</td><td align="center">0x0800_2000~0x0800_3FFF</td><td align="center">8KB</td></tr><tr><td align="center">主闪存</td><td align="center">…..</td><td align="center">…..</td><td align="center">8KB</td></tr><tr><td align="center">主闪存</td><td align="center">Page63</td><td align="center">0x0807_E000~0x0807_FFFF</td><td align="center">8KB</td></tr><tr><td align="center">信息块 CL</td><td align="center">引导Bootloader</td><td align="center">0x1FFF_B000~0x1FFF_F7FF</td><td align="center">18KB</td></tr><tr><td align="center">选项字节</td><td align="center">选项字节</td><td align="center">0x1FFF_F800~0x1FFF_F80F</td><td align="center">16B</td></tr><tr><td align="center">一次性编程</td><td align="center">OTP</td><td align="center">0x1FFF_7000~0x1FFF_77FF</td><td align="center">2KB</td></tr></tbody></table></li><li><p>选项字节说明 : 每次系统复位后，选项字节被重载到FMC_OBSTAT和FMC_WP寄存器后，选项字节生效。选项字节的补字节具体为选项字节取反。当选项字被重载时，如果选项字节的补字节和选项字节补匹配，FMC_OBSTAT的OBERR位将被置1，选项字节被强制设置为0xFF。若选项字节和其补字节同为0xFF，则OBERR位补置位。</p><table><thead><tr><th align="center">地址</th><th align="center">名称</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">0x1FFF_F800</td><td align="center">SPC</td><td align="center">选项字节安全保护值，0xA5未保护，除0xA5和0xCC外的任何值：保护级别低，0xCC：保护级别高</td></tr><tr><td align="center">0x1FFF_F801</td><td align="center">SPC_N</td><td align="center">SPC补字节</td></tr><tr><td align="center">0x1FFF_F802</td><td align="center">USER</td><td align="center">[7:6] : BOR_TH ，BOR复位阈值<br>[5:3] : 保留<br>[2] : nRST_STDBY，0：设置待机模式时产生复位而不是进入待机模式。1：设置待机模式时进入待机模式而不产生复位。<br>[1] : nRST_DPSLP，0：设置深度睡眠模式时产生复位而不进入深度睡眠模式。1：设置深度睡眠模式时进入深度睡眠模式而不产生复位。<br>[0] : nWDG_HW， 0：硬件是能独立看门狗功能。1：软件使能独立看门狗功能。</td></tr><tr><td align="center">0x1FFF_F803</td><td align="center">USER_N</td><td align="center">SPC补字节</td></tr><tr><td align="center">0x1FFF_F804</td><td align="center">DATA[7:0]</td><td align="center">用户定义数据7到0位</td></tr><tr><td align="center">0x1FFF_F805</td><td align="center">DATA_N[7:0]</td><td align="center">DATA补字节的7到0位</td></tr><tr><td align="center">0x1FFF_F806</td><td align="center">DATA[15:8]</td><td align="center">用户定义数据15到8位</td></tr><tr><td align="center">0x1FFF_F807</td><td align="center">DATA_N[15:8]</td><td align="center">DATA补字节的15到8位</td></tr><tr><td align="center">0x1FFF_F808</td><td align="center">WP[7:0]</td><td align="center">页擦除/编程保护值的7到0位 <br>[0] : 保护生效<br>[1] : 未保护</td></tr><tr><td align="center">0x1FFF_F809</td><td align="center">WP_N[7:0]</td><td align="center">WP补字节的7到0位</td></tr><tr><td align="center">0x1FFF_F80A</td><td align="center">WP[15:8]</td><td align="center">页擦除/编程保护值的15到8位</td></tr><tr><td align="center">0x1FFF_F80B</td><td align="center">WP_N[15:8]</td><td align="center">WP补字节的15到8位</td></tr><tr><td align="center">0x1FFF_F80C</td><td align="center">WP[23:16]</td><td align="center">页擦除/编程保护值的23到16位</td></tr><tr><td align="center">0x1FFF_F80D</td><td align="center">WP_N[23:16]</td><td align="center">WP补字节的23到16位</td></tr><tr><td align="center">0x1FFF_F80E</td><td align="center">WP[31:24]</td><td align="center">页擦除/编程保护值的31到24位</td></tr><tr><td align="center">0x1FFF_F80F</td><td align="center">WP_N[31:24]</td><td align="center">WP补字节的31到24位</td></tr></tbody></table></li><li><p>安全防护：<br><strong>未保护状态</strong>：当将SPC字节和它的补字节设置为0x5AA5，系统复位后闪存将处于非安全保护状态，主存储器和选项字节可以被所有操作模式访问。<br><strong>保护等级低</strong>：当设置SPC字节为任何除0xA5或0xCC外的值，系统复位以后，低安全保护状态生效。需要注意的是，若修改过程中，MCU的调试模块依然和外部JTAG/SWD设备相连，需要用上电复位代替系统复位以使得修改后的保护状态生效。在低安全保护状态下，<strong>主存储闪存块仅能被用户代码访问且前8KB的闪存自动处于页擦除/编程保护状态下</strong>。在调试模式下，或从SRAM中启动时，以及从boot loader区启动时，这些模式下对主存储块的操作都被禁止。如果在这些模式下读主存储块，将产生总线错误。如果在这些模式下，对主存储块进行编程或擦除操作，FMC_STAT寄存器的WPERR位将被置1。但这些模式下都可以对选项字节进行操作，从而可以通过该方式失能安全保护功能。如果将SPC字节和它的补字节设置为0x5AA5，安全保护功能将失效，并自动触发一次整片擦除操作。<br><strong>保护等级高</strong>：当设置SPC字节为0xCC，激活高安全保护等级。当编程选择该保护等级时，调试模式，从SRAM中启动，或者从boot loader启动都被禁止。主存储闪存块可由用户代码的所有操作进行访问。SPC字节禁止再次编程。所以，如果高保护等级被激活，将不能再降回到低保护等级或无保护等级。 </p><p><strong><font color=#FF3300>空芯片默认该值为0xFF？所以无法烧写程序？？蛋疼的设计！！</font></strong></p></li></ol><h3 id="例程分析"><a href="#例程分析" class="headerlink" title="例程分析"></a>例程分析</h3><p>Examples/FMC中有三个例程；</p><ol><li>Erase_Program: 提供了fmc_erase_pages和fmc_program的操作例程。</li><li>Security_protection: 设置Security和解unSecurity。</li><li>Write_Protection: 设置写保护，参考意义不大。</li></ol><p>基于以上这三个例程，基本上对flash的操作就不是事了。</p>]]></content>
      
      
      <categories>
          
          <category> MCU </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GD32E505 </tag>
            
            <tag> CortexM33 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GD32E505 USART and DMA</title>
      <link href="/2021/03/23/GD32E50x03DMA/"/>
      <url>/2021/03/23/GD32E50x03DMA/</url>
      
        <content type="html"><![CDATA[<h3 id="GD32E505-DMA："><a href="#GD32E505-DMA：" class="headerlink" title="GD32E505 DMA："></a>GD32E505 DMA：</h3><ol><li>DMA控制器有12个通道，DMA0有7个通道，DMA1有5个通道。</li><li>DMA控制器和Cortex-M33内核共享系统总线。传输长度可配置，最大65536.</li><li>AHB、APB外设、片上闪存和SRAM都可以作为访问的源端和目的端。<br><img src="../../../../medias/boardPic/2021/pcan/DMA0.png" alt="GD32E505 DMA0请求"><br><img src="../../../../medias/boardPic/2021/pcan/DMA1.jpg" alt="GD32E505 DMA1请求"></li><li>支持软件优先级（低、中、高、极高）和硬件优先级（通道号越低，优先级越高）。</li><li>将DMA_CHxCTL寄存器的CHEN位清零，可以停止DMA传输。</li><li>若清零CHEN位时，DMA传输已经完成，之后未对任意寄存器进行操作前便是能DMA通道，则不会触发任何DMA传输。</li></ol><h3 id="GD32E505-USART："><a href="#GD32E505-USART：" class="headerlink" title="GD32E505 USART："></a>GD32E505 USART：</h3><ol><li>所有USART都支持DMA功能，以实现高速率的数据通信。</li><li>IDLE帧检测（IDLEF）;</li><li>USART0/1/2支持全功能，USART3/4有下面功能未实现：<br><strong>智能卡模式<br>同步模式<br>硬件流操作（CTS/RTS）<br>设置数据极性</strong></li><li>USART5跟其他的不一样！！</li></ol><h3 id="例程分析"><a href="#例程分析" class="headerlink" title="例程分析"></a>例程分析</h3><ol><li>Examples\USART 有不少UART的例程，参考DMA的来copy一份改改就可以用了。</li><li>注意：USART5跟其他的不一样！！包括查询状态都不一样！</li><li>填坑：进入空闲中断后的处理也不一样！</li><li>注意USART管脚重映射的配置。RM - P187页</li><li>我用了USART2和USART5做RS485，根据DMA的通道号修改配置DMA模式+IDLE中断，收发都OK了。</li></ol>]]></content>
      
      
      <categories>
          
          <category> MCU </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GD32E505 </tag>
            
            <tag> CortexM33 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GD32E505 USB分析</title>
      <link href="/2021/03/22/GD32E50x02USB/"/>
      <url>/2021/03/22/GD32E50x02USB/</url>
      
        <content type="html"><![CDATA[<h3 id="GD32E505-USBHS模块特性："><a href="#GD32E505-USBHS模块特性：" class="headerlink" title="GD32E505 USBHS模块特性："></a>GD32E505 USBHS模块特性：</h3><ol><li>包含一个4KB的FIFO RAM</li><li>主机模式下，支持12个通道，包含2个发送FIFO（周期性发送FIFO和非周期性发送FIFO）和1个接收FIFO（由所有通道共享）。</li><li>在设备模式下，支持6个OUT端点和6个IN端点。 – 有点少…</li><li>在设备模式下，包含6个发送FIFO（每个IN端点一个发送FIFO）和1个接收FIFO（由所有的OUT端点共享）</li><li>在设备模式下，USBHS在初始化后保持掉电状态，利用VBUS引脚上的5V电源连接USB主机后或者置位<strong>USBHS_GCCFG寄存器中VDEN</strong>控制位，USBHS将进入供电状态。USBHS首先打开DP信号线上的上拉电阻，之后主机会检测到一个连接事件。</li><li>USBHS支持软件断开，通过置位USBHS_DCTL寄存器中SD控制位进行强制断开，SD控制位置位后，如果当前设备为高速，USBHS会首先返回到全速设备，然后关闭DP信号线上的上拉电阻，如果是全速，USBHS会直接关闭上拉电阻，这样USB主机会在USB总线上检测到设备断开。</li></ol><h3 id="例程分析"><a href="#例程分析" class="headerlink" title="例程分析"></a>例程分析</h3><ol><li>usb_rcu_config() : 配置USB的时钟，目测只支持配置system_clock为48M、72M、120M和168M，所以默认程序配置的为168M，没有配置为180M。</li><li>usb_timer_init() : 配置了TIMER2作为USB的延时定时器，usb_mdelay和usb_udelay都是调用了hw_delay来实现的，其他在使用定时器时需要避免使用TIMER2.</li><li>程序中会判断是否需要检测VBUS，配置VBUS_SENSING_ENABLED，在usb_conf.h中屏蔽使能。</li><li>USB设备描述符居然藏在GD32E50x_usbhs_library\device\class\cdc\Source\cdc_acm_core.c，鄙视之！为毛不单独整个文件啊！如果需要修改VID和PID，是在cdc_dev_desc中。</li><li>基本上不需要做什么修改，USB CDC的例程很容易就跑起来了。</li></ol>]]></content>
      
      
      <categories>
          
          <category> MCU </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GD32E505 </tag>
            
            <tag> CortexM33 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GD32E505 Start - 环境搭建</title>
      <link href="/2021/03/21/GD32E50x01Start/"/>
      <url>/2021/03/21/GD32E50x01Start/</url>
      
        <content type="html"><![CDATA[<p>摘掉了CANFD的GD32E505犹如折翼了的天使~光环不再，奈何PCB已做回，好在GD的FAE给力，在芯片价格满天飞的今天提供了10片样片，感动的泪牛满面！纵有千般不爽还是立马搞起！<br><img src="../../../../medias/boardPic/2021/pcan/GD32E505Pic.jpg" alt="GD32E505 Board Pic"></p><h3 id="GD32E505"><a href="#GD32E505" class="headerlink" title="GD32E505"></a>GD32E505</h3><ul><li>180MHz, Arm Cortex-M33 内核，ARMv8架构。</li><li>SRAM/Flash：80/128，96/256，128/512 KB</li><li>高速USB，内置PHY，480Mbit/s。</li><li>两个12bit SAR ADC，2.5MSPS，两个DAC，9个16bit 定时器，一个32bit通用定时器。</li><li>QSPI Flash。</li><li>USART: 高达<strong>22.5MBits/s</strong> ， 支持IrDA SIR编解码，支持LIN，支持ISO7816-3.</li><li>96bits Unique ID，位于0x1FFF_F7E8</li></ul><p>虽然没了CANFD，但还是亮点满满，尤其是内置高速USB PHY，相比STM32来说诚意满满！STM32貌似只有STM32F7有几款型号内置了高速PHY，蛋疼。</p><h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><ol><li>先从GD32官网下载所需资源<br>英文：<a href="http://www.gd32mcu.com/en/download/" target="_blank" rel="noopener">http://www.gd32mcu.com/en/download/</a><br>中文：<a href="http://gd32mcu.com/cn/download" target="_blank" rel="noopener">http://gd32mcu.com/cn/download</a><br>选择GD32E5，主要下载以下几个文件：<br>GD32E505xx_Datasheet_Rev1.2.pdf - 数据手册<br>GD32E50x_RM_Rev1.2.pdf - 寄存器手册<br>GD32E50x_AddOn_V1.2.0.zip - 安装后MDK能识别出GD32E5的芯片<br>GD32E50x_Firmware_Library_V1.1.2.rar - 固件库<br>GD32E50x_Firmware_Library_User_Guide_Rev1.1.rar - 库函数手册<br>GD32E50x_Demo_Suites_V1.1.1.rar - Demo板参考例程，Demo板的原理图也藏在这里面<br>GD32DfuDrivers_V3.6.6.6167.rar - GD32 DFU驱动<br>GD32All_In_OneProgrammer_V1.2.8.9234.rar - 下载程序<br>GD32_Dfu_Tool_V3.8.2.9056.rar - DFU上位机程序<br>GD32_ISP_CLI(Windows)1.0.0.5109.rar - ISP程序<br>GD_Link_Programmer_V4.3.7.9954.rar - GDLink的上位机下载程序</li><li>MDK - 我最开始用的MDK5.23版本，各种问题，后来果断升级至最新版 5.34版本<br>GD32的例程使用的是AC6的编译器。</li><li>JLink驱动：JLink_Windows_V696.exe ，这个版本的支持GD32E505器件，老版本的不支持。</li></ol><h3 id="USB-CDC例程"><a href="#USB-CDC例程" class="headerlink" title="USB CDC例程"></a>USB CDC例程</h3><ol><li>解压GD32E50x_Firmware_Library_V1.1.2.rar</li><li>打开Examples\USBHS\usb_device\cdc_acm\MDK-ARM工程，编译。</li><li>选择JLink，连接方式选择SWD，JTAG/SWD都支持，下载即可。</li></ol><h3 id="埋坑笔记"><a href="#埋坑笔记" class="headerlink" title="埋坑笔记"></a>埋坑笔记</h3><ol><li>例程很多，对每一个外设基本上都有相应的例程，蛋疼的是大部分都没工程，只有几个.c文件。在USBHS中有MDK和IAR的工程，所以直接以此工程入手。</li><li>在MDK5.23版本中，遇到自带的AC6编译时有很多问题，于是从其他高版本的MDK中拷贝出相应的AC6编译链，替换Keil\ARM\ARMCLANG，编译没问题了，在下载选项中没法选择JLink，后来查找到MDK中的描述：<a href="https://www.keil.com/support/docs/4053.htm" target="_blank" rel="noopener">https://www.keil.com/support/docs/4053.htm</a><blockquote><p><strong>µVISION DEBUGGER: J-LINK/J-TRACE Debug Support for ARMv8m Architecture</strong><br>To resolve this issue, open the Keil\Tools.ini file with a text editor and in the section starting with ARMADS search for the debug drivers for Arm v8m architecture and add TDRV4 to the list of supported drivers in CPUDLL3 line.<br>Tools.ini:<br>[ARMADS]<br>CPUDLL0=SARM.DLL(TDRV17,TDRV18,TDRV19)                              # Drivers for ARM7/9 devices<br>CPUDLL1=SARMCM3.DLL(TDRV0,TDRV1,TDRV2,TDRV3,TDRV4,TDRV5,TDRV6,…   # Drivers for Cortex-M devices<br>CPUDLL2=SARMCR4.DLL(TDRV4)                                          # Drivers for Cortex-R4 devices<br>CPUDLL3=SARMV8M.DLL(TDRV2,<strong>TDRV4</strong>,TDRV13,TDRV14,TDRV15,TDRV16)        # Drivers for <strong>ARMv8-M</strong> devices<br>…<br>TDRV3=BIN\CMSIS_AGDI.dll(“CMSIS-DAP Debugger”)<br>TDRV4=<strong>Segger\JL2CM3.dll(“J-LINK / J-TRACE Cortex”)</strong><br>TDRV5=BIN\DbgFM.DLL(“Models Cortex-M Debugger”)<br>…</p></blockquote></li><li>JLink不支持GD32E5的芯片，升级JLink驱动至V696版本即可。Segger的WIKI上还给GD32E507开了个专页，<a href="https://wiki.segger.com/GigaDevice_GD32E5" target="_blank" rel="noopener">https://wiki.segger.com/GigaDevice_GD32E5</a><br>如果使用SEGGER的开发环境，可以下载GigaDevice_GD32E507Z_TestProject_ES_V452b.zip试试。</li><li>我这边还遇到过无法下载的情况，换了电脑换了MDK534还是不行，后来用ISP工具，通过串口给下载了个程序后就OK了，顺便提一下，USB DFU也不行！</li><li>程序下载后无限重启，约1S重启了，各种查找才发现原来是看门狗莫宁奇妙的被开启了，真是日了狗！RM上写的默认是关闭的，但是可以通过配置选项字打开，我也不清楚是个例，还是就这么设计的，程序主循环里不断喂狗就行了。</li><li>能下载能运行了，其他都不是事了，回头慢慢研究吧。</li></ol>]]></content>
      
      
      <categories>
          
          <category> MCU </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GD32E505 </tag>
            
            <tag> CortexM33 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PEAK PCAN</title>
      <link href="/2021/03/21/MyPCAN/"/>
      <url>/2021/03/21/MyPCAN/</url>
      
        <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>Github上又发现了宝，不废话先上网址：<br><strong>PCAN USB</strong> 固件 (支持成品 CANtack、CANable 硬件修改 或者 STMF042系列芯片)：<br><a href="https://github.com/moonglow/pcan_cantact" target="_blank" rel="noopener">https://github.com/moonglow/pcan_cantact</a><br><strong>PCAN USB PRO</strong>  固件(支持STM32F405\407芯片)：<br><a href="https://github.com/moonglow/pcan_pro_x" target="_blank" rel="noopener">https://github.com/moonglow/pcan_pro_x</a></p><h3 id="pcan-cantact-F072版本"><a href="#pcan-cantact-F072版本" class="headerlink" title="pcan_cantact - F072版本"></a>pcan_cantact - F072版本</h3><p>马上拉下代码，一看蒙圈了，没有keil工程，只有Makefile，大体上看了下用的是arm-none-eabi-gcc编译链，我这编译A8的编译链应该不行，懒的配环境了直接动手移植，找个072的工程把其中的源码都删了，然后把pcan_cantact中的代码都先添加进去，然后一编译果然一堆错误，然后就开始对着error一个一个的解决，一番操作猛如虎，一看error 250！应该是startup_stm23f072.s文件的问题，换回之前keil工程里的.s文件，稍作修改就OK了，翻出我的F072的带CAN的小板子down进去一试，居然识别出来了！虽然没有驱动但是很开心，至少说明usb枚举成功了，然后找驱动，官网下载<strong>PeakOemDrv.exe</strong>安装后，就识别出来了！先上板图留念：<br><img src="../../../../medias/boardPic/2021/pcan/PCAN.jpg" alt="PCAN USB - F072"><br><img src="../../../../medias/boardPic/2021/pcan/PCANView.png" alt="PCANView成功识别"><br>再翻出之前买的笨重的USB2CAN工具，连接后配置相同的波特率，收发都正常！代码没做啥修改，只是改了改LED就跑起来了，开心ing…</p><h3 id="PCAN-USB-PRO-F407版本"><a href="#PCAN-USB-PRO-F407版本" class="headerlink" title="PCAN USB PRO - F407版本"></a>PCAN USB PRO - F407版本</h3><p>打铁需趁热，翻出407的板子同样的套路移植好代码，usb上电down程序，又是一番操作猛如虎，NaNi？USB豪无反应！左一想应该时钟不正确，改时钟配置重新下进去还是没反应！好吧，看程序里默认的配置用的应该是8M晶振，算了不改时钟了–换晶振！额…还是不行，看了看USB初始化部分代码居然用的是USBHS！难道需要外扩外扩USB3300来跑高速？不怕，哥有的是板子！翻出之前带USB3300的407板子，继续一番猛如虎的操作，还是毫无反应啊！右一想可能是USB的管脚配置不正确，毕竟ULPI要配置好多个腿，巴拉了巴拉发现USB管脚居然用的是PB14、PB15！奇怪，难道407的高速USB内置了PHY？之前的USB FS都是用的PA11、PA12，不管了，找了个能引出PB14、PB15管脚的407板子，然后把它飞到USB座上，USB线一插听到了熟悉的叮咚声音，虎躯一震，赶紧打开设备管理器一看PCAN USB PRO设备直接识别出来了！呼，长呼一口气！<br>后来看了下人家的README.md文件，上面清晰的注明：</p><p>Target hardware:</p><ul><li>Any STM32F407/405 based boards with 8MHz oscillator<br>Pinout:<table><thead><tr><th>PIN/PINS</th><th>DESCRIPTION</th></tr></thead><tbody><tr><td>PC10</td><td>STATUS LED</td></tr><tr><td>PA2/PA3</td><td>TX/RX CAN1 LED</td></tr><tr><td>PC6/PC7</td><td>TX/RX CAN2 LED</td></tr><tr><td>PB8/PB9</td><td>CAN1 RX/TX</td></tr><tr><td>PB5/PB6</td><td>CAN2 RX/TX</td></tr><tr><td>PB14/PB15</td><td>USB DM/DP</td></tr></tbody></table></li></ul><ul><li>Be sure to use <strong>PB14/PB15</strong> pins for USB</li><li>PRO FD firmware has better performance on windows ( due internal PEAK driver implementation )</li></ul><p>都怪自己太心急绕了些弯路，不过虎躯又一震，还支持CANFD哪！虽然407不支持，但是协议有了，改了改配了配，嗯，果然识别成PCAN-USB Pro FD了，还多了个PCAN-USB-Pro FD LIN！爽歪歪，虽然不知道LIN有啥用。<br>这里的修改主要是在工程配置选项中增加如下配置：PCAN_PRO_FD=1,INCLUDE_LIN_INTERFACE=1,USB_WITHOUT_ISR=0<br>开始改版，用407就不要浪费了，两路CAN、两路LIN、两路RS485，六个LED，SPI Flash，按键，然后今天的主角闪亮登场：<br><img src="../../../../medias/boardPic/2021/pcan/PCANProFD.jpg" alt="MyPCANPro"><br>程序里修改了下LED管脚配置，然后down进去就识别出来了，还是用笨重的USB2CAN工具调试，两路CAN收发都正常！PCAN View可以选择配置CANFD的Norminal Bit Rate和Data Bit Rate，Data Bit Rate只有2MBits/s和6MBits/s两种，不知道是不是固件的原因。<br><img src="../../../../medias/boardPic/2021/pcan/PCANViewCANFD.png" alt="MyPCANPro FD PcanView"><br>还有附送的PLIN，虽然暂时用不到，谁知道以后会不会用上呢~<br><img src="../../../../medias/boardPic/2021/pcan/PLINView.png" alt="PLIN View"></p><h3 id="高速USB-CANFD"><a href="#高速USB-CANFD" class="headerlink" title="高速USB + CANFD"></a>高速USB + CANFD</h3><p>至此虽然已经实现了PCAN，但是没有高速USB没有CANFD，心里总有些遗憾，然后东逛西逛在立创商城上下到了GD32E505的datasheet，虎躯震了又震！这货不就是我一直在找寻的嘛！内置高速USB PHY，至此3路CANFD！选择GD32E505RB/C/E，LQFP64 pin就可以实现了，关于CANFD的描述如下：<br><img src="../../../../medias/boardPic/2021/pcan/E505CANDesc.png" alt="E505 CAN的描述"><br>三路CAN，支持CAN FD，速率也能到6MBit/S！还等什么哪，407的板子还没捂热乎就在它的基础上改出了一个同时支持高速USB、两路CAN FD、QSPI Flash的高级版，立马下单投板。焦急的等板子的过程中找资料找例程，第一次接触GD的片子，可得仔细点~<br>事实再一次狠狠的打了我的脸，快就慢！我以为我捡到了宝结果是一坨屎！CANFD在新版本的datasheet上连个鬼影都木的！别说CANFD了，连CAN都没了！带着一丝丝希望咨询GD的工程师得到如下的回复：<br><strong>“ 505把CAN去掉了，508才有，508还没出样片！”</strong><br>真是句句扎心啊…太坑了…<br>可怜我那可爱的GD32E505xUSBHSxCANFD的小裸板了~<br><img src="../../../../medias/boardPic/2021/pcan/GD32E505Board.jpg" alt="E505Board"></p>]]></content>
      
      
      <categories>
          
          <category> TOOL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PCAN </tag>
            
            <tag> tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的 J-Link 们</title>
      <link href="/2021/03/05/iToos-JLinks/"/>
      <url>/2021/03/05/iToos-JLinks/</url>
      
        <content type="html"><![CDATA[<p>喝水不忘挖井人，感谢Segger提供这么好的工具，感谢XHWW、T大神等的帮助，也感谢凤舞天大哥的支持，这些年学习了很多，也一直都在享受便利的开发，非常非常的感谢~</p><p>同时声明：本人不卖盗版，请支持正版，支持正版，支持正版！</p><h3 id="JLink-Flasher-Portable-Plus"><a href="#JLink-Flasher-Portable-Plus" class="headerlink" title="JLink - Flasher Portable Plus"></a>JLink - Flasher Portable Plus</h3><p>自从Segger的Flasher Portable诞生以来，垂涎滴了又滴，官方介绍如 <a href="https://www.segger.com/products/production/flasher/models/flasher-portable-plus/" target="_blank" rel="noopener">链接</a> ，简单来说就是带1.8寸屏显的离线烧录器，支持N多ARM和非ARM核的芯片，支持JTAG/SWD/FINE/SPD等 <a href="https://www.segger.com/products/debug-probes/j-link/technology/interface-description/" target="_blank" rel="noopener">接口</a>，还自带680mAh的可充电锂电池，超级方便，虽然自个也曾做过离线烧写，基于DAPLink来搞的，但是在量产使用时心里总不放心，最近花了些时间研究下了Flasher Portable，一不小心给搞出来了，非常开心~ 如下图：<br><img src="../../../../medias/boardPic/2021/tools/FlasherPortablePlus.jpg" alt="FlasherPortablePlus Pic"><br>MDK下测试JTAG下载速度可到21000KHZ，SWD却只有12000KHZ，我用足矣。按惯例，去掉接口缓冲芯片（芯片太小，手焊太麻烦，而且我老眼昏花，小芯片上的丝印经常看不清，一不小心就方向焊反了，查找起来太麻烦）、电源输入输出那套啰里啰唆部分电路，然后精简如下：<br><img src="../../../../medias/boardPic/2021/tools/MiniFlashPortable.jpg" alt="Mini FlasherPortablePlus Pic"><br>测试速度不影响，灰常好用，还给赛到了个小盒子里，方便携带~</p><h3 id="JLink-Flasher-Pro-V4"><a href="#JLink-Flasher-Pro-V4" class="headerlink" title="JLink - Flasher Pro V4"></a>JLink - Flasher Pro V4</h3><p>年代比较久远了，出自于XHWW大神之作，后来偶得一正版Flasher Pro，就读出了固件，顺便精简了一下穿上了外衣，非常非常的好用，陪伴我很多年，如下图示：<br><img src="../../../../medias/boardPic/2021/tools/FlasherPro.jpg" alt="Flasher Pro Pic"><br>可惜Flasher系列都不支持虚拟串口，好在有RTT，自从有了RTT，虚拟串口是路人~<br>当然也少不了我的Mini Flasher Pro V4：<br><img src="../../../../medias/boardPic/2021/tools/miniFlasher.jpg" alt="Mini Flasher Pro Pic"></p><h3 id="JLink-Ultra-amp-JLink-Pro-V4"><a href="#JLink-Ultra-amp-JLink-Pro-V4" class="headerlink" title="JLink Ultra &amp; JLink Pro V4"></a>JLink Ultra &amp; JLink Pro V4</h3><p>也是出自于XHWW大神之作，重新修改了下原理及PCB，两层板画下来了，stm32f4+Cyclone4，高速USB、以太网，速度最高能到50000KHz，下载速度很快，但也没那么快，受限于目标芯片的flash速度，下载也就那样，不过配套的JScope可是飞一般的快。第一版的JPro是17年搞的：<br><img src="../../../../medias/boardPic/2021/tools/JUV4.jpg" alt="JLink Ultra &amp; JLink Pro V4 Pic"><br>这个只是偶尔的拿出来用用，大部分时间都在吃灰，但却是一块很不错的arm+fpga的开发板，有需要的时候还可以拿出来鼓捣鼓捣。后来又做了下修改：<br><img src="../../../../medias/boardPic/2021/tools/JProV4.jpg" alt="JLink Ultra &amp; JLink Pro V4 New Pic"></p><h3 id="JLink-V10-amp-JLink-V11"><a href="#JLink-V10-amp-JLink-V11" class="headerlink" title="JLink V10 &amp; JLink V11"></a>JLink V10 &amp; JLink V11</h3><p>依然是出自于XHWW大神之作，JLink V10、V11、Flasher Portable都使用了RSA2048签名，公钥存储在固件中用以验证签名是否正确，不正确不运行，私钥是没办法弄出来的，所以想要破解还是有一定难度的，感兴趣的可以私聊，我也是在XHWW大神的指点下孤岛了好久才不小心给试了出来。<br><img src="../../../../medias/boardPic/2021/tools/V10.jpg" alt="JLink V10 &amp; JLink V11 Pic"><br>顺便提一下，V11的固件是可以在V10上直接运行的，下载速度也没啥变化，不晓得官方做了哪些改动，并且LPC4337也有DAPLink的固件，速度也是非常非常的快。可以按住按键更新不同的程序。<br>同样也少不了Mini V10 &amp; Mini V11，虽然只支持3.3V电平，但是下载速度不受影响：<br><img src="../../../../medias/boardPic/2021/tools/miniV10.jpg" alt="Mini V10 Pic"><br><img src="../../../../medias/boardPic/2021/tools/MiniV11.jpg" alt="Mini V11 Pic"></p><h3 id="JLink-V9"><a href="#JLink-V9" class="headerlink" title="JLink V9"></a>JLink V9</h3><p>V9的年代更是很老了，貌似官方都停止更新了吧？曾经很好用很好用，没啥校验，固件烧上就可以跑，目前dll貌似对序列号后四字节校验做了判断。自从有了V10和mini flasher，就很少用V9了，留照纪念之。<br><img src="../../../../medias/boardPic/2021/tools/V9.jpg" alt="最初的JLink V9 Pic"><br>后来各种改，穿衣服，还和usb hub放一起，再加上个CH34x的一个usb转串口芯片，把Jlink、USB转RS232、USB转RS485、Hub接口都放一起了，也很好用的~<br><img src="../../../../medias/boardPic/2021/tools/iToolsV9.jpg" alt="iToolsV9 Pic"><br>顺便提一下，序列号后四字节的校验如果不正确，Jlinkarm.dll有时会弹出defective的错误框，要么处理下jlinkarm.dll，要么就把这个序列号校验给加上，如果需要可以联系我，可提供针对序列号的校验码。（JLinkarm.dll中有此函数，可惜没有export出来，不过可以找出此函数然后调用它来计算）</p><h3 id="JLink-OB们"><a href="#JLink-OB们" class="headerlink" title="JLink OB们"></a>JLink OB们</h3><p>最初的JLink OB是103，在没有V9之前一直都是OB103陪伴着我，后来有了OB 072，还有了OB K22，貌似OB K22和JLink Mini硬件一致的，而且可用的版本众多，官方貌似开源了原理图了，所以照着画个板写个boot跳到App就可以运行了，其中最牛的是下面这个了：支持4路SWD、3路UART，是在Nodic的NRF91DK开发板上的，原理图都是公开的，照着画个就完事了。在使用一个JLink同时调多个目标板的时候，灰常灰常的好用，按下按键就切过去了~<br><img src="../../../../medias/boardPic/2021/tools/OB072andV9.jpg" alt="JLink OB072 Pic"><br><img src="../../../../medias/boardPic/2021/tools/OBK22.jpg" alt="JLink OBK22 Pic"><br><img src="../../../../medias/boardPic/2021/tools/OBK22s4.jpg" alt="JLink OBK22s4 Pic"></p><h3 id="其他小工具"><a href="#其他小工具" class="headerlink" title="其他小工具"></a>其他小工具</h3><p>JLink SWD ISO: 隔离小板，只隔离SWD，速度不快，调试电机时还是很有必要。<br><img src="../../../../medias/boardPic/2021/tools/JSWDISO.jpg" alt="JLink SWD ISO Pic"><br>Xilinx的JTAG HS3、SMT2，很快，很好用，还有一路虚拟串口，支持选择1.8V/3.3V电平。<br><img src="../../../../medias/boardPic/2021/tools/JTAGH3.jpg" alt="Xilinx FPGA debug tool"></p><h3 id="JLink-CMDs"><a href="#JLink-CMDs" class="headerlink" title="JLink CMDs"></a>JLink CMDs</h3><ol><li>exec InvalidateFW</li><li>exec GetSNChecksum</li><li>exec GetUID</li><li>exec GetSignature</li><li>exec VerifySignature</li><li>exec SetSN</li><li>exec ClearFeatures</li></ol>]]></content>
      
      
      <categories>
          
          <category> TOOL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tools </tag>
            
            <tag> JLink </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2021/03/04/HelloHexo/"/>
      <url>/2021/03/04/HelloHexo/</url>
      
        <content type="html"><![CDATA[<p>Welcome to Hexo  ! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Prepare"><a href="#Prepare" class="headerlink" title="Prepare"></a>Prepare</h3><ol><li>Download and install Git and node, node version : v12.16.0</li><li>test for node and npm, and install hexo.<pre class=" language-bash"><code class="language-bash">$ node -v$ <span class="token function">npm</span> -v$ <span class="token function">npm</span> <span class="token function">install</span> -g hexo</code></pre></li><li>Config git :<pre class=" language-bash"><code class="language-bash">$ <span class="token function">git</span> config --global user.name <span class="token string">"xxx"</span>$ <span class="token function">git</span> config --global user.email <span class="token string">"xxx@xxx.com"</span></code></pre></li><li>如果需要更换git地址或用户等，需要从windows中删除，按如下操作：<br> （1）：进入控制面板<br> （2）：选择用户账户<br> （3）：选择管理你的凭据<br> （4）：选择Windows凭据<br> （5）：选择git保存的用户信息<br> （6）：选择编辑或者进行删除操作<br> （7）：完成</li></ol><h3 id="One-Key-for-test"><a href="#One-Key-for-test" class="headerlink" title="One Key for test"></a>One Key for test</h3><pre class=" language-bash"><code class="language-bash">$ hexo clean <span class="token operator">&amp;</span> hexo g <span class="token operator">&amp;</span> hexo s</code></pre><h3 id="One-Key-for-publish"><a href="#One-Key-for-publish" class="headerlink" title="One Key for publish"></a>One Key for publish</h3><pre class=" language-bash"><code class="language-bash">$ hexo clean <span class="token operator">&amp;</span> hexo g <span class="token operator">&amp;</span> hexo d</code></pre><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> GIT </tag>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CH569 第一篇：GPIO</title>
      <link href="/2020/10/16/CH569_02_GPIO/"/>
      <url>/2020/10/16/CH569_02_GPIO/</url>
      
        <content type="html"><![CDATA[<h3 id="第一篇：GPIO"><a href="#第一篇：GPIO" class="headerlink" title="第一篇：GPIO"></a>第一篇：GPIO</h3><p>额… 从还没入门到放弃~</p>]]></content>
      
      
      <categories>
          
          <category> RiscV </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CH569 </tag>
            
            <tag> Risc-V </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CH569 开篇</title>
      <link href="/2020/10/16/CH569_01_Infor/"/>
      <url>/2020/10/16/CH569_01_Infor/</url>
      
        <content type="html"><![CDATA[<p>终于等到了你：CH569！早早的看到过CH569的介绍，觉得强悍的一批，特别适合搭配一个小FPGA干事，而且价格还不贵，又是国产芯，准备一步一步开始进坑了，先copy一份官网的介绍。</p><h3 id="CH569概述："><a href="#CH569概述：" class="headerlink" title="CH569概述："></a>CH569概述：</h3><p>CH569/565 微控制器使用 RISC-V3A 内核， 支持 RISC-V 指令的 IMAC 子集。 片上集成超高速USB3.0主机和设备控制器（内置 PHY）、千兆以太网控制器、专用高速 SerDes 控制器（内置 PHY，可直接驱动光纤）、高速并行接口HSPI、数字视频接口（DVP）、 SD/EMMC 接口控制器、加解密模块 ， 片上 128 位宽 DMA设计可保障大数据量的高速传输， 可广泛应用于流媒体、即时存储、超高速USB3.0 FIFO、通讯延长、安防监控等应用场景。</p><p><img src="http://www.wch.cn/uploads/image/20200721/Sl2mLGuKpXycnwjU9IlD1ydCxfdKedAORUW3l4BS.png" alt="img"></p><p>功能</p><ul><li>RISC-V内核，120MHz系统主频，支持单周期乘法和硬件除法、可编程中断控制器、低功耗两级流水线</li><li>448KB CodeFlash，32KB DataFlash，16KB的32位宽SRAM，32/64/96KB可配置的128位宽SRAM</li><li>内置超高速USB3.0控制及收发器（内置PHY），支持USB3.0 主机Host/设备Device模式、OTG功能，支持USB3.0 HUB</li><li>内置高速USB2.0控制及收发器（内置PHY），支持USB2.0 主机Host/设备Device模式，支持控制/批量/中断/同步传输</li><li>内置千兆以太网控制器（Ethernet），提供RGMII和RMII PHY接口，支持10/100/1000Mbps的传输速率</li><li>内置数字视频接口DVP，可配置8/10/12位数据宽度，支持YUV、RGB、JPEG压缩数据</li><li>内置高速并行接口HSPI，可配置8/16/32位数据宽度，内置FIFO，支持DMA，最快传输速度约为3.8Gbps</li><li>内置SerDes控制及收发器（内置PHY，可直接驱动光纤），支持网线（仅使用1组差分线）传输90米，支持1.25Gbps高速差分信号通讯</li><li>内置EMMC控制器，支持单线、4线、8线数据通讯模式，符合EMMC卡4.4和4.5.1规范，兼容5.0规范</li><li>支持AES/SM4算法，8种组合加解密模式，支持SRAM/EMMC/HSPI外设接口数据加解密</li><li>4组UART，最高波特率6Mbps，兼容16C550，内置FIFO，多个触发级</li><li>2组SPI接口，支持主从(Master/Slave)模式，内置FIFO，支持DMA</li><li>主动并口：8位数据，15位地址总线</li><li>3组26位定时器，支持定时、计数、信号捕捉、PWM调制输出，4组扩展PWM输出，占空比可调</li><li>49个通用IO，8个可设置电平/边沿中断，部分引脚具有复用及映射功能</li><li>内置看门狗，集成2线调试接口，支持在线仿真</li><li>支持低功耗模式，支持部分GPIO、USB、以太网信号唤醒</li><li>芯片ID号：唯一64bit ID识别号</li><li>封装：QFN68,QFN40</li></ul>]]></content>
      
      
      <categories>
          
          <category> RiscV </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CH569 </tag>
            
            <tag> Risc-V </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>QT SQLite 笔记</title>
      <link href="/2020/04/21/QTSqlNote/"/>
      <url>/2020/04/21/QTSqlNote/</url>
      
        <content type="html"><![CDATA[<h3 id="记录QT-SQLite3"><a href="#记录QT-SQLite3" class="headerlink" title="记录QT SQLite3"></a>记录QT SQLite3</h3><p>如下讨论关于Qt进行SQLite的基本操作。<br>转自：<a href="https://www.cnblogs.com/lvdongjie/p/7068530.html" target="_blank" rel="noopener">https://www.cnblogs.com/lvdongjie/p/7068530.html</a></p><h3 id="添加数据库驱动、设置数据库名称、数据库登录用户名、密码"><a href="#添加数据库驱动、设置数据库名称、数据库登录用户名、密码" class="headerlink" title="添加数据库驱动、设置数据库名称、数据库登录用户名、密码"></a>添加数据库驱动、设置数据库名称、数据库登录用户名、密码</h3><pre class=" language-cpp"><code class="language-cpp">QSqlDatabase database <span class="token operator">=</span> QSqlDatabase<span class="token operator">::</span><span class="token function">addDatabase</span><span class="token punctuation">(</span><span class="token string">"QSQLITE"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> database<span class="token punctuation">.</span><span class="token function">setDatabaseName</span><span class="token punctuation">(</span><span class="token string">"database.db"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>database<span class="token punctuation">.</span><span class="token function">setUserName</span><span class="token punctuation">(</span><span class="token string">"root"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  database<span class="token punctuation">.</span><span class="token function">setPassword</span><span class="token punctuation">(</span><span class="token string">"123456"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="打开数据库"><a href="#打开数据库" class="headerlink" title="打开数据库"></a>打开数据库</h3><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>database<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token function">qDebug</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> database<span class="token punctuation">.</span><span class="token function">lastError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">qFatal</span><span class="token punctuation">(</span><span class="token string">"failed to connect."</span><span class="token punctuation">)</span> <span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//QSqlQuery类提供执行和操作的SQL语句的方法。</span>    <span class="token comment" spellcheck="true">//可以用来执行DML（数据操作语言）语句，如SELECT、INSERT、UPDATE、DELETE， </span>    <span class="token comment" spellcheck="true">//以及DDL（数据定义语言）语句，例如CREATE TABLE。</span>    <span class="token comment" spellcheck="true">//也可以用来执行那些不是标准的SQL的数据库特定的命令。</span>    QSqlQuery sql_query<span class="token punctuation">;</span>     QString create_sql <span class="token operator">=</span> <span class="token string">"create table student (id int primary key, name varchar(30), age int)"</span><span class="token punctuation">;</span>    QString select_max_sql <span class="token operator">=</span> <span class="token string">"select max(id) from student"</span><span class="token punctuation">;</span>    QString insert_sql <span class="token operator">=</span> <span class="token string">"insert into student values (?, ?, ?)"</span><span class="token punctuation">;</span>    QString update_sql <span class="token operator">=</span> <span class="token string">"update student set name = :name where id = :id"</span><span class="token punctuation">;</span>    QString select_sql <span class="token operator">=</span> <span class="token string">"select id, name from student"</span><span class="token punctuation">;</span>    QString select_all_sql <span class="token operator">=</span> <span class="token string">"select * from student"</span><span class="token punctuation">;</span>    QString delete_sql <span class="token operator">=</span> <span class="token string">"delete from student where id = ?"</span><span class="token punctuation">;</span>    QString clear_sql <span class="token operator">=</span> <span class="token string">"delete from student"</span><span class="token punctuation">;</span>    sql_query<span class="token punctuation">.</span><span class="token function">prepare</span><span class="token punctuation">(</span>create_sql<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>sql_query<span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">qDebug</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> sql_query<span class="token punctuation">.</span><span class="token function">lastError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span>    <span class="token punctuation">{</span>        <span class="token function">qDebug</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"table created!"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h3 id="查询最大id"><a href="#查询最大id" class="headerlink" title="查询最大id"></a>查询最大id</h3><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> max_id <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>sql_query<span class="token punctuation">.</span><span class="token function">prepare</span><span class="token punctuation">(</span>select_max_sql<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>sql_query<span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">qDebug</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span> sql_query<span class="token punctuation">.</span><span class="token function">lastError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>sql_query<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        max_id <span class="token operator">=</span> sql_query<span class="token punctuation">.</span><span class="token function">value</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">qDebug</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span> <span class="token function">QString</span><span class="token punctuation">(</span><span class="token string">"max id:%1"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">arg</span><span class="token punctuation">(</span>max_id<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h3><pre class=" language-cpp"><code class="language-cpp">sql_query<span class="token punctuation">.</span><span class="token function">prepare</span><span class="token punctuation">(</span>insert_sql<span class="token punctuation">)</span><span class="token punctuation">;</span>sql_query<span class="token punctuation">.</span><span class="token function">addBindValue</span><span class="token punctuation">(</span>max_id<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>sql_query<span class="token punctuation">.</span><span class="token function">addBindValue</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>sql_query<span class="token punctuation">.</span><span class="token function">addBindValue</span><span class="token punctuation">(</span><span class="token number">25</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>sql_query<span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">qDebug</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span> sql_query<span class="token punctuation">.</span><span class="token function">lastError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>    <span class="token function">qDebug</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span> <span class="token string">"inserted!"</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h3><pre class=" language-cpp"><code class="language-cpp">sql_query<span class="token punctuation">.</span><span class="token function">prepare</span><span class="token punctuation">(</span>update_sql<span class="token punctuation">)</span><span class="token punctuation">;</span>sql_query<span class="token punctuation">.</span><span class="token function">bindValue</span><span class="token punctuation">(</span><span class="token string">":name"</span><span class="token punctuation">,</span> <span class="token string">"Qt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>sql_query<span class="token punctuation">.</span><span class="token function">bindValue</span><span class="token punctuation">(</span><span class="token string">":id"</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>sql_query<span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">qDebug</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span> sql_query<span class="token punctuation">.</span><span class="token function">lastError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>    <span class="token function">qDebug</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span> <span class="token string">"updated!"</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="查询部分数据"><a href="#查询部分数据" class="headerlink" title="查询部分数据"></a>查询部分数据</h3><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>sql_query<span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span>select_sql<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">qDebug</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span> sql_query<span class="token punctuation">.</span><span class="token function">lastError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>sql_query<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">int</span> id <span class="token operator">=</span> sql_query<span class="token punctuation">.</span><span class="token function">value</span><span class="token punctuation">(</span><span class="token string">"id"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        QString name <span class="token operator">=</span> sql_query<span class="token punctuation">.</span><span class="token function">value</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">qDebug</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span> <span class="token function">QString</span><span class="token punctuation">(</span><span class="token string">"id:%1    name:%2"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">arg</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">arg</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="查询所有数据"><a href="#查询所有数据" class="headerlink" title="查询所有数据"></a>查询所有数据</h3><pre class=" language-cpp"><code class="language-cpp">sql_query<span class="token punctuation">.</span><span class="token function">prepare</span><span class="token punctuation">(</span>select_all_sql<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>sql_query<span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">qDebug</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span> sql_query<span class="token punctuation">.</span><span class="token function">lastError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>sql_query<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">int</span> id <span class="token operator">=</span> sql_query<span class="token punctuation">.</span><span class="token function">value</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        QString name <span class="token operator">=</span> sql_query<span class="token punctuation">.</span><span class="token function">value</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> age <span class="token operator">=</span> sql_query<span class="token punctuation">.</span><span class="token function">value</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">qDebug</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span> <span class="token function">QString</span><span class="token punctuation">(</span><span class="token string">"id:%1    name:%2    age:%3"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">arg</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">arg</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">arg</span><span class="token punctuation">(</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><pre class=" language-cpp"><code class="language-cpp">sql_query<span class="token punctuation">.</span><span class="token function">prepare</span><span class="token punctuation">(</span>delete_sql<span class="token punctuation">)</span><span class="token punctuation">;</span>sql_query<span class="token punctuation">.</span><span class="token function">addBindValue</span><span class="token punctuation">(</span>max_id<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>sql_query<span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">qDebug</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span> sql_query<span class="token punctuation">.</span><span class="token function">lastError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>    <span class="token function">qDebug</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span> <span class="token string">"deleted!"</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="清空表"><a href="#清空表" class="headerlink" title="清空表"></a>清空表</h3><pre class=" language-cpp"><code class="language-cpp">sql_query<span class="token punctuation">.</span><span class="token function">prepare</span><span class="token punctuation">(</span>clear_sql<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>sql_query<span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">qDebug</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span> sql_query<span class="token punctuation">.</span><span class="token function">lastError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>    <span class="token function">qDebug</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span> <span class="token string">"cleared"</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="关闭数据库"><a href="#关闭数据库" class="headerlink" title="关闭数据库"></a>关闭数据库</h3><pre class=" language-cpp"><code class="language-cpp">database<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h3><pre class=" language-cpp"><code class="language-cpp">QFile<span class="token operator">::</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token string">"database.db"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="带有加密功能的-SQLite-Qt-插件（v0-5）"><a href="#带有加密功能的-SQLite-Qt-插件（v0-5）" class="headerlink" title="带有加密功能的 SQLite Qt 插件（v0.5）"></a>带有加密功能的 SQLite Qt 插件（v0.5）</h3><p>以下转自：<a href="https://www.devbean.net/2016/05/qt-sqlite-plugin-with-encryption-v05/" target="_blank" rel="noopener">https://www.devbean.net/2016/05/qt-sqlite-plugin-with-encryption-v05/</a><br>QtCipherSqlitePlugin 是一个能够加密 SQLite 数据的 Qt 插件，经过之前几个版本的更新，现在已经有不少使用。</p><p>经过这一次的调整，编译插件变得非常简单：只需要使用 QtCreator 打开插件中 sqlitecipher 文件夹下的 sqlitecipher.pro 进行编译即可。编译后，需要将生成的 sqlitecipher.dll 复制到 Qt 的 plugins/sqldrivers 文件夹下。本次更新。豆子使用 Qt 5.5 和 Qt 5.7 进行了测试，如果有其它版本的 Qt 不能正常使用，请及时联系豆子。</p><p>当然，本次更新我们还是使用了 SQLITECIPHER 作为插件的名字。如果需要修改这个名字，Qt4 需要修改 smain.cpp 中的 DriverName 定义，Qt5 需要修改 SqliteCipherDriverPlugin.json 中的 SQLITECIPHER 一行。</p><p>出去上述调整，更为重要的是，本次更新增加了很多新功能，包括为原来没有密码的 SQLite 数据库添加密码，修改数据库密码以及删除密码。下面我们将着重介绍这些功能的使用。</p><h3 id="检查-QtCipherSqlitePlugin-是否成功加载"><a href="#检查-QtCipherSqlitePlugin-是否成功加载" class="headerlink" title="检查 QtCipherSqlitePlugin 是否成功加载"></a>检查 QtCipherSqlitePlugin 是否成功加载</h3><p>我们可以使用下面的代码检查 QtCipherSqlitePlugin 是否成功加载：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token function">qDebug</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> QSqlDatabase<span class="token operator">::</span><span class="token function">drivers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>如果输出中有 SQLITECIPHER 的名字，那么恭喜你，插件没有问题！</p><h3 id="为没有加密的数据库增加密码"><a href="#为没有加密的数据库增加密码" class="headerlink" title="为没有加密的数据库增加密码"></a>为没有加密的数据库增加密码</h3><p>Qt 默认提供的 SQLite 插件是没有加密功能的。新版本的 QtCipherSqlitePlugin 支持为原本没有加密的数据库增加密码，使用方法如下：</p><pre class=" language-cpp"><code class="language-cpp">QSqlDatabase dbconn <span class="token operator">=</span> QSqlDatabase<span class="token operator">::</span><span class="token function">addDatabase</span><span class="token punctuation">(</span><span class="token string">"SQLITECIPHER"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>dbconn<span class="token punctuation">.</span><span class="token function">setDatabaseName</span><span class="token punctuation">(</span><span class="token string">"test.db"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>dbconn<span class="token punctuation">.</span><span class="token function">setPassword</span><span class="token punctuation">(</span><span class="token string">"test"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>dbconn<span class="token punctuation">.</span><span class="token function">setConnectOptions</span><span class="token punctuation">(</span><span class="token string">"QSQLITE_CREATE_KEY"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>dbconn<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">qDebug</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"Can not open connection: "</span> <span class="token operator">&lt;&lt;</span>         dbconn<span class="token punctuation">.</span><span class="token function">lastError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">driverText</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">exit</span><span class="token punctuation">(</span>CONNECTION_FAILED<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>上面的代码，我们使用 test.db 数据库，将密码设置为 test，同时指定连接选项为QSQLITE_CREATE_KEY。此时，调用open()函数之后，QtCipherSqlitePlugin 将使用改密码为这个数据库进行加密。</p><h3 id="删除数据库密码"><a href="#删除数据库密码" class="headerlink" title="删除数据库密码"></a>删除数据库密码</h3><p>QtCipherSqlitePlugin 可以删除数据库密码，此时需要提供原密码，并使用连接选项QSQLITE_REMOVE_KEY，如下：</p><pre class=" language-cpp"><code class="language-cpp">QSqlDatabase dbconn <span class="token operator">=</span> QSqlDatabase<span class="token operator">::</span><span class="token function">addDatabase</span><span class="token punctuation">(</span><span class="token string">"SQLITECIPHER"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>dbconn<span class="token punctuation">.</span><span class="token function">setDatabaseName</span><span class="token punctuation">(</span><span class="token string">"test.db"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>dbconn<span class="token punctuation">.</span><span class="token function">setPassword</span><span class="token punctuation">(</span><span class="token string">"test"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>dbconn<span class="token punctuation">.</span><span class="token function">setConnectOptions</span><span class="token punctuation">(</span><span class="token string">"QSQLITE_REMOVE_KEY"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>dbconn<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">qDebug</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"Can not open connection: "</span> <span class="token operator">&lt;&lt;</span> dbconn<span class="token punctuation">.</span><span class="token function">lastError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">driverText</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">exit</span><span class="token punctuation">(</span>CONNECTION_FAILED<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="更新数据库密码"><a href="#更新数据库密码" class="headerlink" title="更新数据库密码"></a>更新数据库密码</h3><p>QtCipherSqlitePlugin 可以更新数据库原有密码，需要设置原密码，并且使用连接选项QSQLITE_UPDATE_KEY设置新密码，具体代码如下：</p><pre class=" language-cpp"><code class="language-cpp">QSqlDatabase dbconn <span class="token operator">=</span> QSqlDatabase<span class="token operator">::</span><span class="token function">addDatabase</span><span class="token punctuation">(</span><span class="token string">"SQLITECIPHER"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>dbconn<span class="token punctuation">.</span><span class="token function">setDatabaseName</span><span class="token punctuation">(</span><span class="token string">"test.db"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>dbconn<span class="token punctuation">.</span><span class="token function">setPassword</span><span class="token punctuation">(</span><span class="token string">"test"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>dbconn<span class="token punctuation">.</span><span class="token function">setConnectOptions</span><span class="token punctuation">(</span><span class="token string">"QSQLITE_UPDATE_KEY=newtest"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>dbconn<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">qDebug</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"Can not open connection: "</span> <span class="token operator">&lt;&lt;</span> dbconn<span class="token punctuation">.</span><span class="token function">lastError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">driverText</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">exit</span><span class="token punctuation">(</span>CONNECTION_FAILED<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>如果原密码不正确，QtCipherSqlitePlugin 会直接返回错误。<br>如果新密码设置为空，例如QSQLITE_UPDATE_KEY=，则作用等同于删除密码。<br>如果需要，可以到 github 上面获取 git 库，checkout 代码的 0.5 标签即可。</p><p>GITHUB：<a href="https://github.com/devbean/QtCipherSqlitePlugin" target="_blank" rel="noopener">https://github.com/devbean/QtCipherSqlitePlugin</a></p><h3 id="SQLite的管理"><a href="#SQLite的管理" class="headerlink" title="SQLite的管理"></a>SQLite的管理</h3><p>管理工具挺多的，这里简单介绍几款：<br><strong>SQLite Manager</strong>：开放源代码的SQLite管理工具，用来管理本地电脑上的SQLite数据库，可以独立运行（以XULRunner方式），也可以作为Firefox、Thunderbird、Seamonkey、Songbird、Komodo、Gecko等的插件。<br><strong>SQLite Administrator</strong>：一个用来管理SQLite数据库文件的图形化工具，可进行创建、设计和管理操作。提供代码编辑器具有自动完成和语法着色，支持中文，适合初学者。<br><strong>SQLite Database browser</strong>：一个SQLite数据库的轻量级GUI客户端，基于Qt库开发，界面清洁，操作简单，主要是为非技术用户创建、修改和编辑SQLite数据库的工具，使用向导方式实现。</p>]]></content>
      
      
      <categories>
          
          <category> QT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> QT </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NUC505 - HS USB</title>
      <link href="/2020/02/21/NUC505/"/>
      <url>/2020/02/21/NUC505/</url>
      
        <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>本来做的是M484，看好了它的片上高速USB、双SDHC、QSPI FLash等，结果入了新塘第一坑：LQFP64封装是.4间距的，偶直接拖了个STM32F205的封装过来，.5间距的，结果就是下面这样：<br><img src="../../../../medias/boardPic/2020/M484.jpg" alt="M484 -&gt; NUC505"></p><p>无意间于Whycan论坛（原填坑网）上发现了这款神U：NUC505：</p><ul><li>高速USB Device，USB2.0 USBHost. SD Host.</li><li>128 KSRAM，512KB/2MB SPI Flash（片上无flash）</li><li>含有浮点运算单元和DSP的ARM® Cortex®-M4内核，最高可运行至100MHz</li><li>内建双声道24位音频解码器（某些型号）</li><li>封装友好：LQFP48、QFN48、LQFP64、QFN88.</li></ul><p>相见恨晚啊，这不就是我一直想要的嘛.. 天猫Nuvoton旗舰店一查价格：NUC505DL13Y（2MB SPI FLASH）才￥7.60！便宜的令人发指！！！  那还等什么？立马画板打板，开启了我的“坑”中之旅~~</p><p>先记录下官网用到的软件及文档：</p><ul><li>BSP：NUC505_Series_BSP_CMSIS_V3.03.001.zip</li><li>MDK Pack：Nuvoton.NuMicro_DFP.1.3.5.pack</li></ul><h3 id="坑一：J-Link不支持？"><a href="#坑一：J-Link不支持？" class="headerlink" title="坑一：J-Link不支持？"></a>坑一：J-Link不支持？</h3><p>明明是CortexM4核，明明也支持SWD模式，结果JLink无法识别，打开J-Link commander也没NUC505系列，估计是没给Segger付费吧，可惜了我的MiniJlink和RTT，好用的工具只能暂时放一边了，好在之前参加过几次Nuvoton的研讨会，大方的新塘送的demo板上都有NuLinkMe调试器，暴力掰下来，然后杜邦线连之。</p><p><img src="../../../../medias/boardPic/2020/NDemo.jpg" alt="Nuvoton Demo Board"></p><h3 id="坑二：片内SPI-Flash-And-Boot"><a href="#坑二：片内SPI-Flash-And-Boot" class="headerlink" title="坑二：片内SPI Flash And Boot"></a>坑二：片内SPI Flash And Boot</h3><p>前面多次提到过2MB的片内SPI Flash，2MB看上去很美，但是封的是SPI FLash，虽然支持片上运行，但是速度相比SRAM中运行慢了100倍！没错，是100倍！星爷的那句 “我奶奶骂他欺善民，反被他捉进了<strong>唐府</strong>，xx了一百遍 ！一百遍！！！” 在耳边飘荡…， Github中看到了下面的描述：</p><blockquote><p><em>“ Although code can run directly out of the SPI flash, <strong>execution is understandably SLOOOW</strong>. For this reason, the default Section Placement setting provided for new projects by this package is “Flash Copy to RAM”; however, the usual “Flash” and “RAM” options are provided for completeness as well.</em></p><p><em>The NUC505 has a “Boot from USB” mode where the device appears <strong>as a USB Mass Storage device. A .bin binary image copied to the device is programmed to the internal SPI memory at 0x0.</strong> When the NUC505 is then returned to the “Boot from Internal MCP SPI flash” and restarted, it will attempt to boot from that image. HOWEVER, the “Boot from USB” USB Mass Storage implementation appears to only work in Windows; Linux detects the emulated volume as having corruption and will refuse to mount it for write access.</em></p><p><em>When the NUC505 is set to its “<strong>SWD/ICE Mode with Internal SPI Flash</strong>“ mode, <strong>the NUC505 will NOT execute user code upon hardware reset.</strong> Instead, it runs from its internal mask ROM code and execution eventually reaches an endless loop. This boot mode seems to be intended exclusively for using an IDE to both program memory and specifically initiate debugging execution of the user application.”</em></p></blockquote><p>片上的spi flash看来只能用于代码的存储和boot了，（还可以用于存储一些数据，省了外部的存储了）然后将代码copy到ram里运行，也行，谁让它便宜来，128KB SRAM，分了4个bank，每个32KB，这样就可以作为<u>32K RAM/96 K Flash</u> 或者 <u>64K RAM/64 K Flash</u>的配置来用了，紧着这128K 来回蹂躏吧~</p><p>But，在“SWD/ICE with Internal SPI Flash”模式下无法运行用户代码是什么鬼？尝试了才知道：在这种模式下，可以通过MDK的debug进行程序下载、debug、查看变量、全速运行等等，但是退出debug模式，这货就不跑了！即使按reset也不行，想让它从能从spi flash中自举运行？那得改变它的硬件boot模式才行！只有1111模式下可以直接从内部SPI Flash启动，但是<strong>在这种模式下，仿真器无法连接！！！</strong>真是反人类的设计！！不服？咬他？当心被捉进<strong>唐府</strong>…</p><p>记NUC505的启动配置：（在复位时默认上拉，所以如需配置为0，则相应管脚需加10KR电阻下拉）</p><table><thead><tr><th align="center">PB.4</th><th align="center">PB.3</th><th align="center">PA.10</th><th align="center">PA.9</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center"><strong>1</strong></td><td align="center"><strong>1</strong></td><td align="center"><strong>1</strong></td><td align="center"><strong>1</strong></td><td align="center"><strong>内部MCP SPI FLash启动</strong></td></tr><tr><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center"><font color=#FF3300>0</font></td><td align="center"><strong>USB启动</strong></td></tr><tr><td align="center">1</td><td align="center">1</td><td align="center">0</td><td align="center">1</td><td align="center">外部SPI Flash启动</td></tr><tr><td align="center">1</td><td align="center">0</td><td align="center">1</td><td align="center">1</td><td align="center">ICP模式启动</td></tr><tr><td align="center"><font color=#FF3300>0</font></td><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center"><strong>SWD/ICE + 内部SPI Flash</strong></td></tr><tr><td align="center">0</td><td align="center">1</td><td align="center">1</td><td align="center">0</td><td align="center">SWD/ICE + 外部SPI Flash</td></tr></tbody></table><p>记录我的板子上的调试：</p><ul><li>电阻全都不焊，默认 1111 ： 从片上SPI Flash中启动</li><li><strong>R13 = 10KR， PB4=0， SWD/ICE + 内部SPI Flash ，调试时使用这种模式。</strong></li><li>R3 = 10KR， PA9=0， USB启动。</li></ul><h3 id="坑三：优化精简代码"><a href="#坑三：优化精简代码" class="headerlink" title="坑三：优化精简代码"></a>坑三：优化精简代码</h3><p>官方代码：NUC505_Series_BSP_CMSIS_V3.03.001，压缩包52M左右，解压后先看下Readme.pdf，比较详细的描述了各个目录下的工程等，为了方便备份，我又完整的拷贝了一份解压后的文件，打开NUC505_Series_BSP_CMSIS_V3.03.001\SampleCode\StdDriver\USBD_VCOM_SerialEmulator这个工程，然后开始编译+删除，不断尝试后把不需要用到的都给删除掉并能编译成功，至文件夹大约5MB左右，OK！这就是我要的工程了，以后就在这个上面盖房子就行。</p><p>注：默认配置该工程是使用的SPI FLASH的，需要先设置成“<strong>SWD/ICE + 内部SPI Flash</strong>”模式下，debug下可以运行，也可以下载，然后把启动模式更改为“<strong>内部MCP SPI FLash启动</strong>”，上电即可运行。</p><p>在SampleCode\BootTemplate下有几个例程，参考来实现如何使用SPI Flash和SRAM，目前使用MainOnSram例程，就是启动代码在spi flash中，然后其他大部分程序都是在ram中执行。直接用该例程的ld文件就可以。另外程序稍作配置，将主频配到180M，96M太对不起这内存了。顺便移植了下新塘的NuConsole，跟Segger的RTT类似，在debug模式下打开即可，再插上shell的翅膀，可以起飞啦！</p><p><img src="../../../../medias/boardPic/2020/NuConsole.png" alt="NuConsole"></p><p>顺便再吐槽下他家的NuConsole，虽然功能跟RTT相似，结果请看上图：不支持最大化！只能这么小窗口显示，真是小气的很~</p><h3 id="坑四：新鲜出炉的M484-NUC505"><a href="#坑四：新鲜出炉的M484-NUC505" class="headerlink" title="坑四：新鲜出炉的M484+NUC505"></a>坑四：新鲜出炉的M484+NUC505</h3><p>之前由于封装画错了的M484只能含泪默默重新改版，顺便把NUC505也改了改，加上了oled和按键。</p><p><img src="../../../../medias/boardPic/2020/M484Nuc505.jpg" alt="M484Nuc505"></p><p>NUC505 LQFP封装的可用IO 还是比较少的，目前几乎全用上了，于是在按键输入上又掉坑里了！</p><p>PA0 - 看上去是GPIO管脚，结果该脚使能上拉读出来的值始终为0，查了下手册才发现PA0-ADC_CH0，<strong>内建10KR电阻分压用作电池检测</strong>！内贱啊！！！也没个电路看看如果要测电池电压该怎么接…顺便看了下它的ADC，虽然只有一个ADC，可是玩出了很多花样：</p><ul><li><p>ADC_CH1通道最高可达1MSPS的采样率。</p></li><li><p>ADC_CH2~ADC_CH7:最高200KSPS采样率。</p></li><li><p>ADC_CH2：支持键盘比较器。</p></li><li><p>ADC_CH0：内建10KR电阻分压用作电池检测。</p></li></ul><p>好在OLED一把就点亮了，SPI代码配置真是简洁。</p><h3 id="坑五：VCP-512整数倍发送的问题"><a href="#坑五：VCP-512整数倍发送的问题" class="headerlink" title="坑五：VCP 512整数倍发送的问题"></a>坑五：VCP 512整数倍发送的问题</h3><p>老生常谈的话题了，早在STM32上就有这问题，结果在505上又遇到了，说白了就是在发完整数倍数据包如果还有要发的数据就接着发数据，没有要发的数据了就发个空包就行，在这一点上Nuvoton设计的还是比较人性化的：<br><code>USBD-&gt;EP[EPA].EPRSPCTL = USB_EP_RSPCTL_ZEROLEN;</code><br>对EPRSPCTL的ZERO位置1就会发送一个空包了。至于为啥是512，因为是高速USB嘛，还有一点：可以配置缓冲区为1024，然后收发 一包就是1024Byte，真爽~</p><h3 id="坑六：UART的接收超时中断"><a href="#坑六：UART的接收超时中断" class="headerlink" title="坑六：UART的接收超时中断"></a>坑六：UART的接收超时中断</h3><p>之前用stm32F072时使用串口空闲中断作为接收成帧判断，看NUC505的手册看到UART_TOUT寄存器中的TOIC：当RX FIFO接收到一个新的数据时，定时溢出计数器开始计数，超时后如果RXTOINT为使能，则接收超时中断RXTOINT产生。要求设置为40~255之间，如TOIC为40，则在4个字符时间长度后还没收到新数据，则超时中断产生。看这个描述正正合我的心意！UART1设置46字节fifo的阈值中断，这样使用也可以很大的减轻CPU的负担又能再收到一帧数据后 延时4个字符给出中断，测试时也是OK的，蛋蛋蛋但是：</p><p>当正好发送46字节时，则无超时中断产生，只有UART_INTSTS_RDAINT_Msk中断产生，从此读出数据后，UART_INTSTS_RXTOINT_Msk并未置位，而无论少一个或多一个，都是OK的！</p><p>what’s the ~！M48x的用户别偷笑，你们也有同样的问题！</p><p>查看UART_INTSTS寄存器中<strong>RXTOINT：如果TOUTIEN和RXTOIF都被置1，该位置1.</strong> 跟着看<strong>RXTOIF</strong>的描述：</p><p><strong>当RX FIFO非空且RX FIFO无活动发生，定时溢出计数器等于TOIC时，该位置位</strong>。</p><p>总和之即：超时中断要产生，需要RX FIFO非空，并且TOIC超时溢出并使能。那么问题就在于当正好到RX FIFO阈值中断时，在中断服务函数把数据全都读出来了导致RX FIFO空了，所以就不满足了，自然就无法产生超时溢出中断了！真是蛋疼的设计，那怎么解决呢？解决方法很简单，在阈值中断中让rx fifo不空就完事了。<strong>留一个字节在fifo里！</strong>问题完美解决！</p><p>顺便再吐槽一下：UART0的RX和TX FIFO是16， UART1和UART2的RX TX FIFO是64！就三个UART还整的不一样，顺便赞一下：RS485模式，使用RTS控制485的换向端，真香！</p><h3 id="坑七：NuLink-VS-JLink"><a href="#坑七：NuLink-VS-JLink" class="headerlink" title="坑七：NuLink VS JLink"></a>坑七：<del>NuLink</del> VS <strong>JLink</strong></h3><p>忍受了这么久的NULink，现在终于可以用JLink来欢快的仿真下载调试NUC505了，爽的不要不要的，实现方式很简单，就是在<strong>JLinkDevices.xml</strong>中添加上NUC505的型号就可以了，如下：</p><pre><code>&lt;Device&gt;    &lt;ChipInfo Vendor=&quot;Nuvoton&quot; Name=&quot;NUC505YO13Y&quot; WorkRAMAddr=&quot;0x20000000&quot; WorkRAMSize=&quot;0x00020000&quot; Core=&quot;JLINK_CORE_CORTEX_M4&quot; Aliases=&quot;NUC505DL13Y; NUC505DS13Y&quot;/&gt;    &lt;FlashBankInfo Name=&quot;SPI Flash&quot; BaseAddr=&quot;0x00000000&quot; MaxSize=&quot;0x00200000&quot; Loader=&quot;Devices/Nuvoton/NUC505_SPIFLASH.FLM&quot; LoaderType=&quot;FLASH_ALGO_TYPE_OPEN&quot; /&gt;&lt;/Device&gt;</code></pre><p>然后从keil目录下找到NUC505_SPIFLASH.FLM拷贝到 .\SEGGER\JLink\Devices\Nuvoton目录下即可，就能成功的读到芯片的ID。剩下的跟普通的仿真调试一样了。</p><p>顺便记一下解决仿真时弹出Verification 的ERROR:</p><p><img src="../../../../medias/boardPic/2020/debugError.png" alt="Verification of application image failed."></p><p>先看下下面的 “Download to flash” 是否√了。</p><p><img src="../../../../medias/boardPic/2020/checkDownloadFlash.png" alt="checkDownloadFlash."></p>]]></content>
      
      
      <categories>
          
          <category> ARM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NUC505 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyStm32 - MiniFlasher</title>
      <link href="/2020/02/09/F072MiniFlasher/"/>
      <url>/2020/02/09/F072MiniFlasher/</url>
      
        <content type="html"><![CDATA[<p>使用STM32F072做了一个离线下载器，麻雀虽小然五脏俱全:</p><ul><li>MCU + 8/16 MB SPI Flasher.</li><li>0.96寸 128*64 OLED.</li><li>锂电池充放电管理.</li><li>一键开关机.</li><li>蜂鸣器指示（烧录完成后有提示音）.</li><li>穿上了衣服，有透明外壳.</li></ul><h3 id="Picture"><a href="#Picture" class="headerlink" title="Picture"></a>Picture</h3><p><img src="https://s2.ax1x.com/2020/02/10/14Grmn.jpg" alt="Stm32F072 MiniFlasher"></p><h3 id="离线烧录"><a href="#离线烧录" class="headerlink" title="离线烧录"></a>离线烧录</h3><p>参考移植了DAPLink的代码，烧写速度还是很快的。</p><p>通过MOS管控制对外供电，这样可以在烧写时打开供电，烧录完成后断开供电，可以热插拔了<del>~</del></p><h3 id="SPI-FLash-LittleFS"><a href="#SPI-FLash-LittleFS" class="headerlink" title="SPI FLash - LittleFS"></a>SPI FLash - LittleFS</h3><p>对这个文件系统还是很期待的，好在现在有了<strong>LittleFS Explorer (LFSE) for Windows</strong>工具 ，可以一试。</p><h3 id="GUI"><a href="#GUI" class="headerlink" title="GUI"></a>GUI</h3><p>哪有什么GUI啊，128 * 64 / 8，内存中做了个对应显存，然后全靠画点操作了，速度还是非常非常的快的，加了一个进度条用于烧写进度指示。</p><p>按键支持短按、长按，对于PWR键支持长按关机。</p><p>等有时间了再整理代码吧<del>~</del></p>]]></content>
      
      
      <categories>
          
          <category> STM32 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM32 </tag>
            
            <tag> STM32F072 </tag>
            
            <tag> Flasher </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
