<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>GD32E505 Flash 操作</title>
      <link href="/2021/04/12/GD32E50x04Flash/"/>
      <url>/2021/04/12/GD32E50x04Flash/</url>
      
        <content type="html"><![CDATA[<h3 id="GD32E505-Flash："><a href="#GD32E505-Flash：" class="headerlink" title="GD32E505 Flash："></a>GD32E505 Flash：</h3><ol><li><p>设备唯一ID（UNIQUE ID ,96bit，只能按字32位访问），基地址：0x1FFF_F7E8</p></li><li><p>闪存的前512K字节空间内，CPU执行指令需要0~4个等待时间。</p></li><li><p>闪存页大小为<strong>8KB</strong>，支持32位字/16位半字编程，页擦除和整片擦除。</p></li><li><p>2K字节 OTP块（一次性编程），用于存储用户数据。</p></li><li><p>16字节的选项字节，根据用户需求配置，当系统复位时，选项字节被加载到选项字节控制寄存器。</p></li><li><p>GD32E505_CL闪存基地址和构成：</p><table><thead><tr><th align="center">闪存</th><th align="center">名称</th><th align="center">地址范围</th><th align="center">大小</th></tr></thead><tbody><tr><td align="center">主闪存</td><td align="center">Page0</td><td align="center">0x0800_0000~0x0800_1FFF</td><td align="center">8KB</td></tr><tr><td align="center">主闪存</td><td align="center">Page1</td><td align="center">0x0800_2000~0x0800_3FFF</td><td align="center">8KB</td></tr><tr><td align="center">主闪存</td><td align="center">…..</td><td align="center">…..</td><td align="center">8KB</td></tr><tr><td align="center">主闪存</td><td align="center">Page63</td><td align="center">0x0807_E000~0x0807_FFFF</td><td align="center">8KB</td></tr><tr><td align="center">信息块 CL</td><td align="center">引导Bootloader</td><td align="center">0x1FFF_B000~0x1FFF_F7FF</td><td align="center">18KB</td></tr><tr><td align="center">选项字节</td><td align="center">选项字节</td><td align="center">0x1FFF_F800~0x1FFF_F80F</td><td align="center">16B</td></tr><tr><td align="center">一次性编程</td><td align="center">OTP</td><td align="center">0x1FFF_7000~0x1FFF_77FF</td><td align="center">2KB</td></tr></tbody></table></li><li><p>选项字节说明 : 每次系统复位后，选项字节被重载到FMC_OBSTAT和FMC_WP寄存器后，选项字节生效。选项字节的补字节具体为选项字节取反。当选项字被重载时，如果选项字节的补字节和选项字节补匹配，FMC_OBSTAT的OBERR位将被置1，选项字节被强制设置为0xFF。若选项字节和其补字节同为0xFF，则OBERR位补置位。</p><table><thead><tr><th align="center">地址</th><th align="center">名称</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">0x1FFF_F800</td><td align="center">SPC</td><td align="center">选项字节安全保护值，0xA5未保护，除0xA5和0xCC外的任何值：保护级别低，0xCC：保护级别高</td></tr><tr><td align="center">0x1FFF_F801</td><td align="center">SPC_N</td><td align="center">SPC补字节</td></tr><tr><td align="center">0x1FFF_F802</td><td align="center">USER</td><td align="center">[7:6] : BOR_TH ，BOR复位阈值<br>[5:3] : 保留<br>[2] : nRST_STDBY，0：设置待机模式时产生复位而不是进入待机模式。1：设置待机模式时进入待机模式而不产生复位。<br>[1] : nRST_DPSLP，0：设置深度睡眠模式时产生复位而不进入深度睡眠模式。1：设置深度睡眠模式时进入深度睡眠模式而不产生复位。<br>[0] : nWDG_HW， 0：硬件是能独立看门狗功能。1：软件使能独立看门狗功能。</td></tr><tr><td align="center">0x1FFF_F803</td><td align="center">USER_N</td><td align="center">SPC补字节</td></tr><tr><td align="center">0x1FFF_F804</td><td align="center">DATA[7:0]</td><td align="center">用户定义数据7到0位</td></tr><tr><td align="center">0x1FFF_F805</td><td align="center">DATA_N[7:0]</td><td align="center">DATA补字节的7到0位</td></tr><tr><td align="center">0x1FFF_F806</td><td align="center">DATA[15:8]</td><td align="center">用户定义数据15到8位</td></tr><tr><td align="center">0x1FFF_F807</td><td align="center">DATA_N[15:8]</td><td align="center">DATA补字节的15到8位</td></tr><tr><td align="center">0x1FFF_F808</td><td align="center">WP[7:0]</td><td align="center">页擦除/编程保护值的7到0位 <br>[0] : 保护生效<br>[1] : 未保护</td></tr><tr><td align="center">0x1FFF_F809</td><td align="center">WP_N[7:0]</td><td align="center">WP补字节的7到0位</td></tr><tr><td align="center">0x1FFF_F80A</td><td align="center">WP[15:8]</td><td align="center">页擦除/编程保护值的15到8位</td></tr><tr><td align="center">0x1FFF_F80B</td><td align="center">WP_N[15:8]</td><td align="center">WP补字节的15到8位</td></tr><tr><td align="center">0x1FFF_F80C</td><td align="center">WP[23:16]</td><td align="center">页擦除/编程保护值的23到16位</td></tr><tr><td align="center">0x1FFF_F80D</td><td align="center">WP_N[23:16]</td><td align="center">WP补字节的23到16位</td></tr><tr><td align="center">0x1FFF_F80E</td><td align="center">WP[31:24]</td><td align="center">页擦除/编程保护值的31到24位</td></tr><tr><td align="center">0x1FFF_F80F</td><td align="center">WP_N[31:24]</td><td align="center">WP补字节的31到24位</td></tr></tbody></table></li><li><p>安全防护：<br><strong>未保护状态</strong>：当将SPC字节和它的补字节设置为0x5AA5，系统复位后闪存将处于非安全保护状态，主存储器和选项字节可以被所有操作模式访问。<br><strong>保护等级低</strong>：当设置SPC字节为任何除0xA5或0xCC外的值，系统复位以后，低安全保护状态生效。需要注意的是，若修改过程中，MCU的调试模块依然和外部JTAG/SWD设备相连，需要用上电复位代替系统复位以使得修改后的保护状态生效。在低安全保护状态下，<strong>主存储闪存块仅能被用户代码访问且前8KB的闪存自动处于页擦除/编程保护状态下</strong>。在调试模式下，或从SRAM中启动时，以及从boot loader区启动时，这些模式下对主存储块的操作都被禁止。如果在这些模式下读主存储块，将产生总线错误。如果在这些模式下，对主存储块进行编程或擦除操作，FMC_STAT寄存器的WPERR位将被置1。但这些模式下都可以对选项字节进行操作，从而可以通过该方式失能安全保护功能。如果将SPC字节和它的补字节设置为0x5AA5，安全保护功能将失效，并自动触发一次整片擦除操作。<br><strong>保护等级高</strong>：当设置SPC字节为0xCC，激活高安全保护等级。当编程选择该保护等级时，调试模式，从SRAM中启动，或者从boot loader启动都被禁止。主存储闪存块可由用户代码的所有操作进行访问。SPC字节禁止再次编程。所以，如果高保护等级被激活，将不能再降回到低保护等级或无保护等级。 </p><p><strong><font color=#FF3300>空芯片默认该值为0xFF？所以无法烧写程序？？蛋疼的设计！！</font></strong></p></li></ol><h3 id="例程分析"><a href="#例程分析" class="headerlink" title="例程分析"></a>例程分析</h3><p>Examples/FMC中有三个例程；</p><ol><li>Erase_Program: 提供了fmc_erase_pages和fmc_program的操作例程。</li><li>Security_protection: 设置Security和解unSecurity。</li><li>Write_Protection: 设置写保护，参考意义不大。</li></ol><p>基于以上这三个例程，基本上对flash的操作就不是事了。</p>]]></content>
      
      
      <categories>
          
          <category> MCU </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GD32E505 </tag>
            
            <tag> CortexM33 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GD32E505 USART and DMA</title>
      <link href="/2021/03/23/GD32E50x03DMA/"/>
      <url>/2021/03/23/GD32E50x03DMA/</url>
      
        <content type="html"><![CDATA[<h3 id="GD32E505-DMA："><a href="#GD32E505-DMA：" class="headerlink" title="GD32E505 DMA："></a>GD32E505 DMA：</h3><ol><li>DMA控制器有12个通道，DMA0有7个通道，DMA1有5个通道。</li><li>DMA控制器和Cortex-M33内核共享系统总线。传输长度可配置，最大65536.</li><li>AHB、APB外设、片上闪存和SRAM都可以作为访问的源端和目的端。<br><img src="../../../../medias/boardPic/2021/pcan/DMA0.png" alt="GD32E505 DMA0请求"><br><img src="../../../../medias/boardPic/2021/pcan/DMA1.jpg" alt="GD32E505 DMA1请求"></li><li>支持软件优先级（低、中、高、极高）和硬件优先级（通道号越低，优先级越高）。</li><li>将DMA_CHxCTL寄存器的CHEN位清零，可以停止DMA传输。</li><li>若清零CHEN位时，DMA传输已经完成，之后未对任意寄存器进行操作前便是能DMA通道，则不会触发任何DMA传输。</li></ol><h3 id="GD32E505-USART："><a href="#GD32E505-USART：" class="headerlink" title="GD32E505 USART："></a>GD32E505 USART：</h3><ol><li>所有USART都支持DMA功能，以实现高速率的数据通信。</li><li>IDLE帧检测（IDLEF）;</li><li>USART0/1/2支持全功能，USART3/4有下面功能未实现：<br><strong>智能卡模式<br>同步模式<br>硬件流操作（CTS/RTS）<br>设置数据极性</strong></li><li>USART5跟其他的不一样！！</li></ol><h3 id="例程分析"><a href="#例程分析" class="headerlink" title="例程分析"></a>例程分析</h3><ol><li>Examples\USART 有不少UART的例程，参考DMA的来copy一份改改就可以用了。</li><li>注意：USART5跟其他的不一样！！包括查询状态都不一样！</li><li>填坑：进入空闲中断后的处理也不一样！</li><li>注意USART管脚重映射的配置。RM - P187页</li><li>我用了USART2和USART5做RS485，根据DMA的通道号修改配置DMA模式+IDLE中断，收发都OK了。</li></ol>]]></content>
      
      
      <categories>
          
          <category> MCU </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GD32E505 </tag>
            
            <tag> CortexM33 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GD32E505 USB分析</title>
      <link href="/2021/03/22/GD32E50x02USB/"/>
      <url>/2021/03/22/GD32E50x02USB/</url>
      
        <content type="html"><![CDATA[<h3 id="GD32E505-USBHS模块特性："><a href="#GD32E505-USBHS模块特性：" class="headerlink" title="GD32E505 USBHS模块特性："></a>GD32E505 USBHS模块特性：</h3><ol><li>包含一个4KB的FIFO RAM</li><li>主机模式下，支持12个通道，包含2个发送FIFO（周期性发送FIFO和非周期性发送FIFO）和1个接收FIFO（由所有通道共享）。</li><li>在设备模式下，支持6个OUT端点和6个IN端点。 – 有点少…</li><li>在设备模式下，包含6个发送FIFO（每个IN端点一个发送FIFO）和1个接收FIFO（由所有的OUT端点共享）</li><li>在设备模式下，USBHS在初始化后保持掉电状态，利用VBUS引脚上的5V电源连接USB主机后或者置位<strong>USBHS_GCCFG寄存器中VDEN</strong>控制位，USBHS将进入供电状态。USBHS首先打开DP信号线上的上拉电阻，之后主机会检测到一个连接事件。</li><li>USBHS支持软件断开，通过置位USBHS_DCTL寄存器中SD控制位进行强制断开，SD控制位置位后，如果当前设备为高速，USBHS会首先返回到全速设备，然后关闭DP信号线上的上拉电阻，如果是全速，USBHS会直接关闭上拉电阻，这样USB主机会在USB总线上检测到设备断开。</li></ol><h3 id="例程分析"><a href="#例程分析" class="headerlink" title="例程分析"></a>例程分析</h3><ol><li>usb_rcu_config() : 配置USB的时钟，目测只支持配置system_clock为48M、72M、120M和168M，所以默认程序配置的为168M，没有配置为180M。</li><li>usb_timer_init() : 配置了TIMER2作为USB的延时定时器，usb_mdelay和usb_udelay都是调用了hw_delay来实现的，其他在使用定时器时需要避免使用TIMER2.</li><li>程序中会判断是否需要检测VBUS，配置VBUS_SENSING_ENABLED，在usb_conf.h中屏蔽使能。</li><li>USB设备描述符居然藏在GD32E50x_usbhs_library\device\class\cdc\Source\cdc_acm_core.c，鄙视之！为毛不单独整个文件啊！如果需要修改VID和PID，是在cdc_dev_desc中。</li><li>基本上不需要做什么修改，USB CDC的例程很容易就跑起来了。</li></ol>]]></content>
      
      
      <categories>
          
          <category> MCU </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GD32E505 </tag>
            
            <tag> CortexM33 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GD32E505 Start - 环境搭建</title>
      <link href="/2021/03/21/GD32E50x01Start/"/>
      <url>/2021/03/21/GD32E50x01Start/</url>
      
        <content type="html"><![CDATA[<p>摘掉了CANFD的GD32E505犹如折翼了的天使~光环不再，奈何PCB已做回，好在GD的FAE给力，在芯片价格满天飞的今天提供了10片样片，感动的泪牛满面！纵有千般不爽还是立马搞起！<br><img src="../../../../medias/boardPic/2021/pcan/GD32E505Pic.jpg" alt="GD32E505 Board Pic"></p><h3 id="GD32E505"><a href="#GD32E505" class="headerlink" title="GD32E505"></a>GD32E505</h3><ul><li>180MHz, Arm Cortex-M33 内核，ARMv8架构。</li><li>SRAM/Flash：80/128，96/256，128/512 KB</li><li>高速USB，内置PHY，480Mbit/s。</li><li>两个12bit SAR ADC，2.5MSPS，两个DAC，9个16bit 定时器，一个32bit通用定时器。</li><li>QSPI Flash。</li><li>USART: 高达<strong>22.5MBits/s</strong> ， 支持IrDA SIR编解码，支持LIN，支持ISO7816-3.</li><li>96bits Unique ID，位于0x1FFF_F7E8</li></ul><p>虽然没了CANFD，但还是亮点满满，尤其是内置高速USB PHY，相比STM32来说诚意满满！STM32貌似只有STM32F7有几款型号内置了高速PHY，蛋疼。</p><h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><ol><li>先从GD32官网下载所需资源<br>英文：<a href="http://www.gd32mcu.com/en/download/" target="_blank" rel="noopener">http://www.gd32mcu.com/en/download/</a><br>中文：<a href="http://gd32mcu.com/cn/download" target="_blank" rel="noopener">http://gd32mcu.com/cn/download</a><br>选择GD32E5，主要下载以下几个文件：<br>GD32E505xx_Datasheet_Rev1.2.pdf - 数据手册<br>GD32E50x_RM_Rev1.2.pdf - 寄存器手册<br>GD32E50x_AddOn_V1.2.0.zip - 安装后MDK能识别出GD32E5的芯片<br>GD32E50x_Firmware_Library_V1.1.2.rar - 固件库<br>GD32E50x_Firmware_Library_User_Guide_Rev1.1.rar - 库函数手册<br>GD32E50x_Demo_Suites_V1.1.1.rar - Demo板参考例程，Demo板的原理图也藏在这里面<br>GD32DfuDrivers_V3.6.6.6167.rar - GD32 DFU驱动<br>GD32All_In_OneProgrammer_V1.2.8.9234.rar - 下载程序<br>GD32_Dfu_Tool_V3.8.2.9056.rar - DFU上位机程序<br>GD32_ISP_CLI(Windows)1.0.0.5109.rar - ISP程序<br>GD_Link_Programmer_V4.3.7.9954.rar - GDLink的上位机下载程序</li><li>MDK - 我最开始用的MDK5.23版本，各种问题，后来果断升级至最新版 5.34版本<br>GD32的例程使用的是AC6的编译器。</li><li>JLink驱动：JLink_Windows_V696.exe ，这个版本的支持GD32E505器件，老版本的不支持。</li></ol><h3 id="USB-CDC例程"><a href="#USB-CDC例程" class="headerlink" title="USB CDC例程"></a>USB CDC例程</h3><ol><li>解压GD32E50x_Firmware_Library_V1.1.2.rar</li><li>打开Examples\USBHS\usb_device\cdc_acm\MDK-ARM工程，编译。</li><li>选择JLink，连接方式选择SWD，JTAG/SWD都支持，下载即可。</li></ol><h3 id="埋坑笔记"><a href="#埋坑笔记" class="headerlink" title="埋坑笔记"></a>埋坑笔记</h3><ol><li>例程很多，对每一个外设基本上都有相应的例程，蛋疼的是大部分都没工程，只有几个.c文件。在USBHS中有MDK和IAR的工程，所以直接以此工程入手。</li><li>在MDK5.23版本中，遇到自带的AC6编译时有很多问题，于是从其他高版本的MDK中拷贝出相应的AC6编译链，替换Keil\ARM\ARMCLANG，编译没问题了，在下载选项中没法选择JLink，后来查找到MDK中的描述：<a href="https://www.keil.com/support/docs/4053.htm" target="_blank" rel="noopener">https://www.keil.com/support/docs/4053.htm</a><blockquote><p><strong>µVISION DEBUGGER: J-LINK/J-TRACE Debug Support for ARMv8m Architecture</strong><br>To resolve this issue, open the Keil\Tools.ini file with a text editor and in the section starting with ARMADS search for the debug drivers for Arm v8m architecture and add TDRV4 to the list of supported drivers in CPUDLL3 line.<br>Tools.ini:<br>[ARMADS]<br>CPUDLL0=SARM.DLL(TDRV17,TDRV18,TDRV19)                              # Drivers for ARM7/9 devices<br>CPUDLL1=SARMCM3.DLL(TDRV0,TDRV1,TDRV2,TDRV3,TDRV4,TDRV5,TDRV6,…   # Drivers for Cortex-M devices<br>CPUDLL2=SARMCR4.DLL(TDRV4)                                          # Drivers for Cortex-R4 devices<br>CPUDLL3=SARMV8M.DLL(TDRV2,<strong>TDRV4</strong>,TDRV13,TDRV14,TDRV15,TDRV16)        # Drivers for <strong>ARMv8-M</strong> devices<br>…<br>TDRV3=BIN\CMSIS_AGDI.dll(“CMSIS-DAP Debugger”)<br>TDRV4=<strong>Segger\JL2CM3.dll(“J-LINK / J-TRACE Cortex”)</strong><br>TDRV5=BIN\DbgFM.DLL(“Models Cortex-M Debugger”)<br>…</p></blockquote></li><li>JLink不支持GD32E5的芯片，升级JLink驱动至V696版本即可。Segger的WIKI上还给GD32E507开了个专页，<a href="https://wiki.segger.com/GigaDevice_GD32E5" target="_blank" rel="noopener">https://wiki.segger.com/GigaDevice_GD32E5</a><br>如果使用SEGGER的开发环境，可以下载GigaDevice_GD32E507Z_TestProject_ES_V452b.zip试试。</li><li>我这边还遇到过无法下载的情况，换了电脑换了MDK534还是不行，后来用ISP工具，通过串口给下载了个程序后就OK了，顺便提一下，USB DFU也不行！</li><li>程序下载后无限重启，约1S重启了，各种查找才发现原来是看门狗莫宁奇妙的被开启了，真是日了狗！RM上写的默认是关闭的，但是可以通过配置选项字打开，我也不清楚是个例，还是就这么设计的，程序主循环里不断喂狗就行了。</li><li>能下载能运行了，其他都不是事了，回头慢慢研究吧。</li></ol>]]></content>
      
      
      <categories>
          
          <category> MCU </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GD32E505 </tag>
            
            <tag> CortexM33 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PEAK PCAN</title>
      <link href="/2021/03/21/MyPCAN/"/>
      <url>/2021/03/21/MyPCAN/</url>
      
        <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>Github上又发现了宝，不废话先上网址：<br><strong>PCAN USB</strong> 固件 (支持成品 CANtack、CANable 硬件修改 或者 STMF042系列芯片)：<br><a href="https://github.com/moonglow/pcan_cantact" target="_blank" rel="noopener">https://github.com/moonglow/pcan_cantact</a><br><strong>PCAN USB PRO</strong>  固件(支持STM32F405\407芯片)：<br><a href="https://github.com/moonglow/pcan_pro_x" target="_blank" rel="noopener">https://github.com/moonglow/pcan_pro_x</a></p><h3 id="pcan-cantact-F072版本"><a href="#pcan-cantact-F072版本" class="headerlink" title="pcan_cantact - F072版本"></a>pcan_cantact - F072版本</h3><p>马上拉下代码，一看蒙圈了，没有keil工程，只有Makefile，大体上看了下用的是arm-none-eabi-gcc编译链，我这编译A8的编译链应该不行，懒的配环境了直接动手移植，找个072的工程把其中的源码都删了，然后把pcan_cantact中的代码都先添加进去，然后一编译果然一堆错误，然后就开始对着error一个一个的解决，一番操作猛如虎，一看error 250！应该是startup_stm23f072.s文件的问题，换回之前keil工程里的.s文件，稍作修改就OK了，翻出我的F072的带CAN的小板子down进去一试，居然识别出来了！虽然没有驱动但是很开心，至少说明usb枚举成功了，然后找驱动，官网下载<strong>PeakOemDrv.exe</strong>安装后，就识别出来了！先上板图留念：<br><img src="../../../../medias/boardPic/2021/pcan/PCAN.jpg" alt="PCAN USB - F072"><br><img src="../../../../medias/boardPic/2021/pcan/PCANView.png" alt="PCANView成功识别"><br>再翻出之前买的笨重的USB2CAN工具，连接后配置相同的波特率，收发都正常！代码没做啥修改，只是改了改LED就跑起来了，开心ing…</p><h3 id="PCAN-USB-PRO-F407版本"><a href="#PCAN-USB-PRO-F407版本" class="headerlink" title="PCAN USB PRO - F407版本"></a>PCAN USB PRO - F407版本</h3><p>打铁需趁热，翻出407的板子同样的套路移植好代码，usb上电down程序，又是一番操作猛如虎，NaNi？USB豪无反应！左一想应该时钟不正确，改时钟配置重新下进去还是没反应！好吧，看程序里默认的配置用的应该是8M晶振，算了不改时钟了–换晶振！额…还是不行，看了看USB初始化部分代码居然用的是USBHS！难道需要外扩外扩USB3300来跑高速？不怕，哥有的是板子！翻出之前带USB3300的407板子，继续一番猛如虎的操作，还是毫无反应啊！右一想可能是USB的管脚配置不正确，毕竟ULPI要配置好多个腿，巴拉了巴拉发现USB管脚居然用的是PB14、PB15！奇怪，难道407的高速USB内置了PHY？之前的USB FS都是用的PA11、PA12，不管了，找了个能引出PB14、PB15管脚的407板子，然后把它飞到USB座上，USB线一插听到了熟悉的叮咚声音，虎躯一震，赶紧打开设备管理器一看PCAN USB PRO设备直接识别出来了！呼，长呼一口气！<br>后来看了下人家的README.md文件，上面清晰的注明：</p><p>Target hardware:</p><ul><li>Any STM32F407/405 based boards with 8MHz oscillator<br>Pinout:<table><thead><tr><th>PIN/PINS</th><th>DESCRIPTION</th></tr></thead><tbody><tr><td>PC10</td><td>STATUS LED</td></tr><tr><td>PA2/PA3</td><td>TX/RX CAN1 LED</td></tr><tr><td>PC6/PC7</td><td>TX/RX CAN2 LED</td></tr><tr><td>PB8/PB9</td><td>CAN1 RX/TX</td></tr><tr><td>PB5/PB6</td><td>CAN2 RX/TX</td></tr><tr><td>PB14/PB15</td><td>USB DM/DP</td></tr></tbody></table></li></ul><ul><li>Be sure to use <strong>PB14/PB15</strong> pins for USB</li><li>PRO FD firmware has better performance on windows ( due internal PEAK driver implementation )</li></ul><p>都怪自己太心急绕了些弯路，不过虎躯又一震，还支持CANFD哪！虽然407不支持，但是协议有了，改了改配了配，嗯，果然识别成PCAN-USB Pro FD了，还多了个PCAN-USB-Pro FD LIN！爽歪歪，虽然不知道LIN有啥用。<br>这里的修改主要是在工程配置选项中增加如下配置：PCAN_PRO_FD=1,INCLUDE_LIN_INTERFACE=1,USB_WITHOUT_ISR=0<br>开始改版，用407就不要浪费了，两路CAN、两路LIN、两路RS485，六个LED，SPI Flash，按键，然后今天的主角闪亮登场：<br><img src="../../../../medias/boardPic/2021/pcan/PCANProFD.jpg" alt="MyPCANPro"><br>程序里修改了下LED管脚配置，然后down进去就识别出来了，还是用笨重的USB2CAN工具调试，两路CAN收发都正常！PCAN View可以选择配置CANFD的Norminal Bit Rate和Data Bit Rate，Data Bit Rate只有2MBits/s和6MBits/s两种，不知道是不是固件的原因。<br><img src="../../../../medias/boardPic/2021/pcan/PCANViewCANFD.png" alt="MyPCANPro FD PcanView"><br>还有附送的PLIN，虽然暂时用不到，谁知道以后会不会用上呢~<br><img src="../../../../medias/boardPic/2021/pcan/PLINView.png" alt="PLIN View"></p><h3 id="高速USB-CANFD"><a href="#高速USB-CANFD" class="headerlink" title="高速USB + CANFD"></a>高速USB + CANFD</h3><p>至此虽然已经实现了PCAN，但是没有高速USB没有CANFD，心里总有些遗憾，然后东逛西逛在立创商城上下到了GD32E505的datasheet，虎躯震了又震！这货不就是我一直在找寻的嘛！内置高速USB PHY，至此3路CANFD！选择GD32E505RB/C/E，LQFP64 pin就可以实现了，关于CANFD的描述如下：<br><img src="../../../../medias/boardPic/2021/pcan/E505CANDesc.png" alt="E505 CAN的描述"><br>三路CAN，支持CAN FD，速率也能到6MBit/S！还等什么哪，407的板子还没捂热乎就在它的基础上改出了一个同时支持高速USB、两路CAN FD、QSPI Flash的高级版，立马下单投板。焦急的等板子的过程中找资料找例程，第一次接触GD的片子，可得仔细点~<br>事实再一次狠狠的打了我的脸，快就慢！我以为我捡到了宝结果是一坨屎！CANFD在新版本的datasheet上连个鬼影都木的！别说CANFD了，连CAN都没了！带着一丝丝希望咨询GD的工程师得到如下的回复：<br><strong>“ 505把CAN去掉了，508才有，508还没出样片！”</strong><br>真是句句扎心啊…太坑了…<br>可怜我那可爱的GD32E505xUSBHSxCANFD的小裸板了~<br><img src="../../../../medias/boardPic/2021/pcan/GD32E505Board.jpg" alt="E505Board"></p>]]></content>
      
      
      <categories>
          
          <category> TOOL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PCAN </tag>
            
            <tag> tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的 J-Link 们</title>
      <link href="/2021/03/05/iToos-JLinks/"/>
      <url>/2021/03/05/iToos-JLinks/</url>
      
        <content type="html"><![CDATA[<p>喝水不忘挖井人，感谢Segger提供这么好的工具，感谢XHWW、T大神等的帮助，也感谢凤舞天大哥的支持，这些年学习了很多，也一直都在享受便利的开发，非常非常的感谢~</p><p>同时声明：本人不卖盗版，请支持正版，支持正版，支持正版！</p><h3 id="JLink-Flasher-Portable-Plus"><a href="#JLink-Flasher-Portable-Plus" class="headerlink" title="JLink - Flasher Portable Plus"></a>JLink - Flasher Portable Plus</h3><p>自从Segger的Flasher Portable诞生以来，垂涎滴了又滴，官方介绍如 <a href="https://www.segger.com/products/production/flasher/models/flasher-portable-plus/" target="_blank" rel="noopener">链接</a> ，简单来说就是带1.8寸屏显的离线烧录器，支持N多ARM和非ARM核的芯片，支持JTAG/SWD/FINE/SPD等 <a href="https://www.segger.com/products/debug-probes/j-link/technology/interface-description/" target="_blank" rel="noopener">接口</a>，还自带680mAh的可充电锂电池，超级方便，虽然自个也曾做过离线烧写，基于DAPLink来搞的，但是在量产使用时心里总不放心，最近花了些时间研究下了Flasher Portable，一不小心给搞出来了，非常开心~ 如下图：<br><img src="../../../../medias/boardPic/2021/tools/FlasherPortablePlus.jpg" alt="FlasherPortablePlus Pic"><br>MDK下测试JTAG下载速度可到21000KHZ，SWD却只有12000KHZ，我用足矣。按惯例，去掉接口缓冲芯片（芯片太小，手焊太麻烦，而且我老眼昏花，小芯片上的丝印经常看不清，一不小心就方向焊反了，查找起来太麻烦）、电源输入输出那套啰里啰唆部分电路，然后精简如下：<br><img src="../../../../medias/boardPic/2021/tools/MiniFlashPortable.jpg" alt="Mini FlasherPortablePlus Pic"><br>测试速度不影响，灰常好用，还给赛到了个小盒子里，方便携带~</p><h3 id="JLink-Flasher-Pro-V4"><a href="#JLink-Flasher-Pro-V4" class="headerlink" title="JLink - Flasher Pro V4"></a>JLink - Flasher Pro V4</h3><p>年代比较久远了，出自于XHWW大神之作，后来偶得一正版Flasher Pro，就读出了固件，顺便精简了一下穿上了外衣，非常非常的好用，陪伴我很多年，如下图示：<br><img src="../../../../medias/boardPic/2021/tools/FlasherPro.jpg" alt="Flasher Pro Pic"><br>可惜Flasher系列都不支持虚拟串口，好在有RTT，自从有了RTT，虚拟串口是路人~<br>当然也少不了我的Mini Flasher Pro V4：<br><img src="../../../../medias/boardPic/2021/tools/miniFlasher.jpg" alt="Mini Flasher Pro Pic"></p><h3 id="JLink-Ultra-amp-JLink-Pro-V4"><a href="#JLink-Ultra-amp-JLink-Pro-V4" class="headerlink" title="JLink Ultra &amp; JLink Pro V4"></a>JLink Ultra &amp; JLink Pro V4</h3><p>也是出自于XHWW大神之作，重新修改了下原理及PCB，两层板画下来了，stm32f4+Cyclone4，高速USB、以太网，速度最高能到50000KHz，下载速度很快，但也没那么快，受限于目标芯片的flash速度，下载也就那样，不过配套的JScope可是飞一般的快。第一版的JPro是17年搞的：<br><img src="../../../../medias/boardPic/2021/tools/JUV4.jpg" alt="JLink Ultra &amp; JLink Pro V4 Pic"><br>这个只是偶尔的拿出来用用，大部分时间都在吃灰，但却是一块很不错的arm+fpga的开发板，有需要的时候还可以拿出来鼓捣鼓捣。后来又做了下修改：<br><img src="../../../../medias/boardPic/2021/tools/JProV4.jpg" alt="JLink Ultra &amp; JLink Pro V4 New Pic"></p><h3 id="JLink-V10-amp-JLink-V11"><a href="#JLink-V10-amp-JLink-V11" class="headerlink" title="JLink V10 &amp; JLink V11"></a>JLink V10 &amp; JLink V11</h3><p>依然是出自于XHWW大神之作，JLink V10、V11、Flasher Portable都使用了RSA2048签名，公钥存储在固件中用以验证签名是否正确，不正确不运行，私钥是没办法弄出来的，所以想要破解还是有一定难度的，感兴趣的可以私聊，我也是在XHWW大神的指点下孤岛了好久才不小心给试了出来。<br><img src="../../../../medias/boardPic/2021/tools/V10.jpg" alt="JLink V10 &amp; JLink V11 Pic"><br>顺便提一下，V11的固件是可以在V10上直接运行的，下载速度也没啥变化，不晓得官方做了哪些改动，并且LPC4337也有DAPLink的固件，速度也是非常非常的快。可以按住按键更新不同的程序。<br>同样也少不了Mini V10 &amp; Mini V11，虽然只支持3.3V电平，但是下载速度不受影响：<br><img src="../../../../medias/boardPic/2021/tools/miniV10.jpg" alt="Mini V10 Pic"><br><img src="../../../../medias/boardPic/2021/tools/MiniV11.jpg" alt="Mini V11 Pic"></p><h3 id="JLink-V9"><a href="#JLink-V9" class="headerlink" title="JLink V9"></a>JLink V9</h3><p>V9的年代更是很老了，貌似官方都停止更新了吧？曾经很好用很好用，没啥校验，固件烧上就可以跑，目前dll貌似对序列号后四字节校验做了判断。自从有了V10和mini flasher，就很少用V9了，留照纪念之。<br><img src="../../../../medias/boardPic/2021/tools/V9.jpg" alt="最初的JLink V9 Pic"><br>后来各种改，穿衣服，还和usb hub放一起，再加上个CH34x的一个usb转串口芯片，把Jlink、USB转RS232、USB转RS485、Hub接口都放一起了，也很好用的~<br><img src="../../../../medias/boardPic/2021/tools/iToolsV9.jpg" alt="iToolsV9 Pic"><br>顺便提一下，序列号后四字节的校验如果不正确，Jlinkarm.dll有时会弹出defective的错误框，要么处理下jlinkarm.dll，要么就把这个序列号校验给加上，如果需要可以联系我，可提供针对序列号的校验码。（JLinkarm.dll中有此函数，可惜没有export出来，不过可以找出此函数然后调用它来计算）</p><h3 id="JLink-OB们"><a href="#JLink-OB们" class="headerlink" title="JLink OB们"></a>JLink OB们</h3><p>最初的JLink OB是103，在没有V9之前一直都是OB103陪伴着我，后来有了OB 072，还有了OB K22，貌似OB K22和JLink Mini硬件一致的，而且可用的版本众多，官方貌似开源了原理图了，所以照着画个板写个boot跳到App就可以运行了，其中最牛的是下面这个了：支持4路SWD、3路UART，是在Nodic的NRF91DK开发板上的，原理图都是公开的，照着画个就完事了。在使用一个JLink同时调多个目标板的时候，灰常灰常的好用，按下按键就切过去了~<br><img src="../../../../medias/boardPic/2021/tools/OB072andV9.jpg" alt="JLink OB072 Pic"><br><img src="../../../../medias/boardPic/2021/tools/OBK22.jpg" alt="JLink OBK22 Pic"><br><img src="../../../../medias/boardPic/2021/tools/OBK22s4.jpg" alt="JLink OBK22s4 Pic"></p><h3 id="其他小工具"><a href="#其他小工具" class="headerlink" title="其他小工具"></a>其他小工具</h3><p>JLink SWD ISO: 隔离小板，只隔离SWD，速度不快，调试电机时还是很有必要。<br><img src="../../../../medias/boardPic/2021/tools/JSWDISO.jpg" alt="JLink SWD ISO Pic"><br>Xilinx的JTAG HS3、SMT2，很快，很好用，还有一路虚拟串口，支持选择1.8V/3.3V电平。<br><img src="../../../../medias/boardPic/2021/tools/JTAGH3.jpg" alt="Xilinx FPGA debug tool"></p><h3 id="JLink-CMDs"><a href="#JLink-CMDs" class="headerlink" title="JLink CMDs"></a>JLink CMDs</h3><ol><li>exec InvalidateFW</li><li>exec GetSNChecksum</li><li>exec GetUID</li><li>exec GetSignature</li><li>exec VerifySignature</li><li>exec SetSN</li><li>exec ClearFeatures</li></ol>]]></content>
      
      
      <categories>
          
          <category> TOOL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tools </tag>
            
            <tag> JLink </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2021/03/04/HelloHexo/"/>
      <url>/2021/03/04/HelloHexo/</url>
      
        <content type="html"><![CDATA[<p>Welcome to Hexo  ! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Prepare"><a href="#Prepare" class="headerlink" title="Prepare"></a>Prepare</h3><ol><li>Download and install Git and node, node version : v12.16.0</li><li>test for node and npm, and install hexo.<pre class=" language-bash"><code class="language-bash">$ node -v$ <span class="token function">npm</span> -v$ <span class="token function">npm</span> <span class="token function">install</span> -g hexo</code></pre></li><li>Config git :<pre class=" language-bash"><code class="language-bash">$ <span class="token function">git</span> config --global user.name <span class="token string">"xxx"</span>$ <span class="token function">git</span> config --global user.email <span class="token string">"xxx@xxx.com"</span></code></pre></li><li>如果需要更换git地址或用户等，需要从windows中删除，按如下操作：<br> （1）：进入控制面板<br> （2）：选择用户账户<br> （3）：选择管理你的凭据<br> （4）：选择Windows凭据<br> （5）：选择git保存的用户信息<br> （6）：选择编辑或者进行删除操作<br> （7）：完成</li></ol><h3 id="One-Key-for-test"><a href="#One-Key-for-test" class="headerlink" title="One Key for test"></a>One Key for test</h3><pre class=" language-bash"><code class="language-bash">$ hexo clean <span class="token operator">&amp;</span> hexo g <span class="token operator">&amp;</span> hexo s</code></pre><h3 id="One-Key-for-publish"><a href="#One-Key-for-publish" class="headerlink" title="One Key for publish"></a>One Key for publish</h3><pre class=" language-bash"><code class="language-bash">$ hexo clean <span class="token operator">&amp;</span> hexo g <span class="token operator">&amp;</span> hexo d</code></pre><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> GIT </tag>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CH569 第一篇：GPIO</title>
      <link href="/2020/10/16/CH569_02_GPIO/"/>
      <url>/2020/10/16/CH569_02_GPIO/</url>
      
        <content type="html"><![CDATA[<h3 id="第一篇：GPIO"><a href="#第一篇：GPIO" class="headerlink" title="第一篇：GPIO"></a>第一篇：GPIO</h3><p>额… 从还没入门到放弃~</p>]]></content>
      
      
      <categories>
          
          <category> RiscV </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CH569 </tag>
            
            <tag> Risc-V </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CH569 开篇</title>
      <link href="/2020/10/16/CH569_01_Infor/"/>
      <url>/2020/10/16/CH569_01_Infor/</url>
      
        <content type="html"><![CDATA[<p>终于等到了你：CH569！早早的看到过CH569的介绍，觉得强悍的一批，特别适合搭配一个小FPGA干事，而且价格还不贵，又是国产芯，准备一步一步开始进坑了，先copy一份官网的介绍。</p><h3 id="CH569概述："><a href="#CH569概述：" class="headerlink" title="CH569概述："></a>CH569概述：</h3><p>CH569/565 微控制器使用 RISC-V3A 内核， 支持 RISC-V 指令的 IMAC 子集。 片上集成超高速USB3.0主机和设备控制器（内置 PHY）、千兆以太网控制器、专用高速 SerDes 控制器（内置 PHY，可直接驱动光纤）、高速并行接口HSPI、数字视频接口（DVP）、 SD/EMMC 接口控制器、加解密模块 ， 片上 128 位宽 DMA设计可保障大数据量的高速传输， 可广泛应用于流媒体、即时存储、超高速USB3.0 FIFO、通讯延长、安防监控等应用场景。</p><p><img src="http://www.wch.cn/uploads/image/20200721/Sl2mLGuKpXycnwjU9IlD1ydCxfdKedAORUW3l4BS.png" alt="img"></p><p>功能</p><ul><li>RISC-V内核，120MHz系统主频，支持单周期乘法和硬件除法、可编程中断控制器、低功耗两级流水线</li><li>448KB CodeFlash，32KB DataFlash，16KB的32位宽SRAM，32/64/96KB可配置的128位宽SRAM</li><li>内置超高速USB3.0控制及收发器（内置PHY），支持USB3.0 主机Host/设备Device模式、OTG功能，支持USB3.0 HUB</li><li>内置高速USB2.0控制及收发器（内置PHY），支持USB2.0 主机Host/设备Device模式，支持控制/批量/中断/同步传输</li><li>内置千兆以太网控制器（Ethernet），提供RGMII和RMII PHY接口，支持10/100/1000Mbps的传输速率</li><li>内置数字视频接口DVP，可配置8/10/12位数据宽度，支持YUV、RGB、JPEG压缩数据</li><li>内置高速并行接口HSPI，可配置8/16/32位数据宽度，内置FIFO，支持DMA，最快传输速度约为3.8Gbps</li><li>内置SerDes控制及收发器（内置PHY，可直接驱动光纤），支持网线（仅使用1组差分线）传输90米，支持1.25Gbps高速差分信号通讯</li><li>内置EMMC控制器，支持单线、4线、8线数据通讯模式，符合EMMC卡4.4和4.5.1规范，兼容5.0规范</li><li>支持AES/SM4算法，8种组合加解密模式，支持SRAM/EMMC/HSPI外设接口数据加解密</li><li>4组UART，最高波特率6Mbps，兼容16C550，内置FIFO，多个触发级</li><li>2组SPI接口，支持主从(Master/Slave)模式，内置FIFO，支持DMA</li><li>主动并口：8位数据，15位地址总线</li><li>3组26位定时器，支持定时、计数、信号捕捉、PWM调制输出，4组扩展PWM输出，占空比可调</li><li>49个通用IO，8个可设置电平/边沿中断，部分引脚具有复用及映射功能</li><li>内置看门狗，集成2线调试接口，支持在线仿真</li><li>支持低功耗模式，支持部分GPIO、USB、以太网信号唤醒</li><li>芯片ID号：唯一64bit ID识别号</li><li>封装：QFN68,QFN40</li></ul>]]></content>
      
      
      <categories>
          
          <category> RiscV </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CH569 </tag>
            
            <tag> Risc-V </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NUC505 - HS USB</title>
      <link href="/2020/02/21/NUC505/"/>
      <url>/2020/02/21/NUC505/</url>
      
        <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>本来做的是M484，看好了它的片上高速USB、双SDHC、QSPI FLash等，结果入了新塘第一坑：LQFP64封装是.4间距的，偶直接拖了个STM32F205的封装过来，.5间距的，结果就是下面这样：<br><img src="../../../../medias/boardPic/2020/M484.jpg" alt="M484 -&gt; NUC505"></p><p>无意间于Whycan论坛（原填坑网）上发现了这款神U：NUC505：</p><ul><li>高速USB Device，USB2.0 USBHost. SD Host.</li><li>128 KSRAM，512KB/2MB SPI Flash（片上无flash）</li><li>含有浮点运算单元和DSP的ARM® Cortex®-M4内核，最高可运行至100MHz</li><li>内建双声道24位音频解码器（某些型号）</li><li>封装友好：LQFP48、QFN48、LQFP64、QFN88.</li></ul><p>相见恨晚啊，这不就是我一直想要的嘛.. 天猫Nuvoton旗舰店一查价格：NUC505DL13Y（2MB SPI FLASH）才￥7.60！便宜的令人发指！！！  那还等什么？立马画板打板，开启了我的“坑”中之旅~~</p><p>先记录下官网用到的软件及文档：</p><ul><li>BSP：NUC505_Series_BSP_CMSIS_V3.03.001.zip</li><li>MDK Pack：Nuvoton.NuMicro_DFP.1.3.5.pack</li></ul><h3 id="坑一：J-Link不支持？"><a href="#坑一：J-Link不支持？" class="headerlink" title="坑一：J-Link不支持？"></a>坑一：J-Link不支持？</h3><p>明明是CortexM4核，明明也支持SWD模式，结果JLink无法识别，打开J-Link commander也没NUC505系列，估计是没给Segger付费吧，可惜了我的MiniJlink和RTT，好用的工具只能暂时放一边了，好在之前参加过几次Nuvoton的研讨会，大方的新塘送的demo板上都有NuLinkMe调试器，暴力掰下来，然后杜邦线连之。</p><p><img src="../../../../medias/boardPic/2020/NDemo.jpg" alt="Nuvoton Demo Board"></p><h3 id="坑二：片内SPI-Flash-And-Boot"><a href="#坑二：片内SPI-Flash-And-Boot" class="headerlink" title="坑二：片内SPI Flash And Boot"></a>坑二：片内SPI Flash And Boot</h3><p>前面多次提到过2MB的片内SPI Flash，2MB看上去很美，但是封的是SPI FLash，虽然支持片上运行，但是速度相比SRAM中运行慢了100倍！没错，是100倍！星爷的那句 “我奶奶骂他欺善民，反被他捉进了<strong>唐府</strong>，xx了一百遍 ！一百遍！！！” 在耳边飘荡…， Github中看到了下面的描述：</p><blockquote><p><em>“ Although code can run directly out of the SPI flash, <strong>execution is understandably SLOOOW</strong>. For this reason, the default Section Placement setting provided for new projects by this package is “Flash Copy to RAM”; however, the usual “Flash” and “RAM” options are provided for completeness as well.</em></p><p><em>The NUC505 has a “Boot from USB” mode where the device appears <strong>as a USB Mass Storage device. A .bin binary image copied to the device is programmed to the internal SPI memory at 0x0.</strong> When the NUC505 is then returned to the “Boot from Internal MCP SPI flash” and restarted, it will attempt to boot from that image. HOWEVER, the “Boot from USB” USB Mass Storage implementation appears to only work in Windows; Linux detects the emulated volume as having corruption and will refuse to mount it for write access.</em></p><p><em>When the NUC505 is set to its “<strong>SWD/ICE Mode with Internal SPI Flash</strong>“ mode, <strong>the NUC505 will NOT execute user code upon hardware reset.</strong> Instead, it runs from its internal mask ROM code and execution eventually reaches an endless loop. This boot mode seems to be intended exclusively for using an IDE to both program memory and specifically initiate debugging execution of the user application.”</em></p></blockquote><p>片上的spi flash看来只能用于代码的存储和boot了，（还可以用于存储一些数据，省了外部的存储了）然后将代码copy到ram里运行，也行，谁让它便宜来，128KB SRAM，分了4个bank，每个32KB，这样就可以作为<u>32K RAM/96 K Flash</u> 或者 <u>64K RAM/64 K Flash</u>的配置来用了，紧着这128K 来回蹂躏吧~</p><p>But，在“SWD/ICE with Internal SPI Flash”模式下无法运行用户代码是什么鬼？尝试了才知道：在这种模式下，可以通过MDK的debug进行程序下载、debug、查看变量、全速运行等等，但是退出debug模式，这货就不跑了！即使按reset也不行，想让它从能从spi flash中自举运行？那得改变它的硬件boot模式才行！只有1111模式下可以直接从内部SPI Flash启动，但是<strong>在这种模式下，仿真器无法连接！！！</strong>真是反人类的设计！！不服？咬他？当心被捉进<strong>唐府</strong>…</p><p>记NUC505的启动配置：（在复位时默认上拉，所以如需配置为0，则相应管脚需加10KR电阻下拉）</p><table><thead><tr><th align="center">PB.4</th><th align="center">PB.3</th><th align="center">PA.10</th><th align="center">PA.9</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center"><strong>1</strong></td><td align="center"><strong>1</strong></td><td align="center"><strong>1</strong></td><td align="center"><strong>1</strong></td><td align="center"><strong>内部MCP SPI FLash启动</strong></td></tr><tr><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center"><font color=#FF3300>0</font></td><td align="center"><strong>USB启动</strong></td></tr><tr><td align="center">1</td><td align="center">1</td><td align="center">0</td><td align="center">1</td><td align="center">外部SPI Flash启动</td></tr><tr><td align="center">1</td><td align="center">0</td><td align="center">1</td><td align="center">1</td><td align="center">ICP模式启动</td></tr><tr><td align="center"><font color=#FF3300>0</font></td><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center"><strong>SWD/ICE + 内部SPI Flash</strong></td></tr><tr><td align="center">0</td><td align="center">1</td><td align="center">1</td><td align="center">0</td><td align="center">SWD/ICE + 外部SPI Flash</td></tr></tbody></table><p>记录我的板子上的调试：</p><ul><li>电阻全都不焊，默认 1111 ： 从片上SPI Flash中启动</li><li><strong>R13 = 10KR， PB4=0， SWD/ICE + 内部SPI Flash ，调试时使用这种模式。</strong></li><li>R3 = 10KR， PA9=0， USB启动。</li></ul><h3 id="坑三：优化精简代码"><a href="#坑三：优化精简代码" class="headerlink" title="坑三：优化精简代码"></a>坑三：优化精简代码</h3><p>官方代码：NUC505_Series_BSP_CMSIS_V3.03.001，压缩包52M左右，解压后先看下Readme.pdf，比较详细的描述了各个目录下的工程等，为了方便备份，我又完整的拷贝了一份解压后的文件，打开NUC505_Series_BSP_CMSIS_V3.03.001\SampleCode\StdDriver\USBD_VCOM_SerialEmulator这个工程，然后开始编译+删除，不断尝试后把不需要用到的都给删除掉并能编译成功，至文件夹大约5MB左右，OK！这就是我要的工程了，以后就在这个上面盖房子就行。</p><p>注：默认配置该工程是使用的SPI FLASH的，需要先设置成“<strong>SWD/ICE + 内部SPI Flash</strong>”模式下，debug下可以运行，也可以下载，然后把启动模式更改为“<strong>内部MCP SPI FLash启动</strong>”，上电即可运行。</p><p>在SampleCode\BootTemplate下有几个例程，参考来实现如何使用SPI Flash和SRAM，目前使用MainOnSram例程，就是启动代码在spi flash中，然后其他大部分程序都是在ram中执行。直接用该例程的ld文件就可以。另外程序稍作配置，将主频配到180M，96M太对不起这内存了。顺便移植了下新塘的NuConsole，跟Segger的RTT类似，在debug模式下打开即可，再插上shell的翅膀，可以起飞啦！</p><p><img src="../../../../medias/boardPic/2020/NuConsole.png" alt="NuConsole"></p><p>顺便再吐槽下他家的NuConsole，虽然功能跟RTT相似，结果请看上图：不支持最大化！只能这么小窗口显示，真是小气的很~</p><h3 id="坑四：新鲜出炉的M484-NUC505"><a href="#坑四：新鲜出炉的M484-NUC505" class="headerlink" title="坑四：新鲜出炉的M484+NUC505"></a>坑四：新鲜出炉的M484+NUC505</h3><p>之前由于封装画错了的M484只能含泪默默重新改版，顺便把NUC505也改了改，加上了oled和按键。</p><p><img src="../../../../medias/boardPic/2020/M484Nuc505.jpg" alt="M484Nuc505"></p><p>NUC505 LQFP封装的可用IO 还是比较少的，目前几乎全用上了，于是在按键输入上又掉坑里了！</p><p>PA0 - 看上去是GPIO管脚，结果该脚使能上拉读出来的值始终为0，查了下手册才发现PA0-ADC_CH0，<strong>内建10KR电阻分压用作电池检测</strong>！内贱啊！！！也没个电路看看如果要测电池电压该怎么接…顺便看了下它的ADC，虽然只有一个ADC，可是玩出了很多花样：</p><ul><li><p>ADC_CH1通道最高可达1MSPS的采样率。</p></li><li><p>ADC_CH2~ADC_CH7:最高200KSPS采样率。</p></li><li><p>ADC_CH2：支持键盘比较器。</p></li><li><p>ADC_CH0：内建10KR电阻分压用作电池检测。</p></li></ul><p>好在OLED一把就点亮了，SPI代码配置真是简洁。</p><h3 id="坑五：VCP-512整数倍发送的问题"><a href="#坑五：VCP-512整数倍发送的问题" class="headerlink" title="坑五：VCP 512整数倍发送的问题"></a>坑五：VCP 512整数倍发送的问题</h3><p>老生常谈的话题了，早在STM32上就有这问题，结果在505上又遇到了，说白了就是在发完整数倍数据包如果还有要发的数据就接着发数据，没有要发的数据了就发个空包就行，在这一点上Nuvoton设计的还是比较人性化的：<br><code>USBD-&gt;EP[EPA].EPRSPCTL = USB_EP_RSPCTL_ZEROLEN;</code><br>对EPRSPCTL的ZERO位置1就会发送一个空包了。至于为啥是512，因为是高速USB嘛，还有一点：可以配置缓冲区为1024，然后收发 一包就是1024Byte，真爽~</p><h3 id="坑六：UART的接收超时中断"><a href="#坑六：UART的接收超时中断" class="headerlink" title="坑六：UART的接收超时中断"></a>坑六：UART的接收超时中断</h3><p>之前用stm32F072时使用串口空闲中断作为接收成帧判断，看NUC505的手册看到UART_TOUT寄存器中的TOIC：当RX FIFO接收到一个新的数据时，定时溢出计数器开始计数，超时后如果RXTOINT为使能，则接收超时中断RXTOINT产生。要求设置为40~255之间，如TOIC为40，则在4个字符时间长度后还没收到新数据，则超时中断产生。看这个描述正正合我的心意！UART1设置46字节fifo的阈值中断，这样使用也可以很大的减轻CPU的负担又能再收到一帧数据后 延时4个字符给出中断，测试时也是OK的，蛋蛋蛋但是：</p><p>当正好发送46字节时，则无超时中断产生，只有UART_INTSTS_RDAINT_Msk中断产生，从此读出数据后，UART_INTSTS_RXTOINT_Msk并未置位，而无论少一个或多一个，都是OK的！</p><p>what’s the ~！M48x的用户别偷笑，你们也有同样的问题！</p><p>查看UART_INTSTS寄存器中<strong>RXTOINT：如果TOUTIEN和RXTOIF都被置1，该位置1.</strong> 跟着看<strong>RXTOIF</strong>的描述：</p><p><strong>当RX FIFO非空且RX FIFO无活动发生，定时溢出计数器等于TOIC时，该位置位</strong>。</p><p>总和之即：超时中断要产生，需要RX FIFO非空，并且TOIC超时溢出并使能。那么问题就在于当正好到RX FIFO阈值中断时，在中断服务函数把数据全都读出来了导致RX FIFO空了，所以就不满足了，自然就无法产生超时溢出中断了！真是蛋疼的设计，那怎么解决呢？解决方法很简单，在阈值中断中让rx fifo不空就完事了。<strong>留一个字节在fifo里！</strong>问题完美解决！</p><p>顺便再吐槽一下：UART0的RX和TX FIFO是16， UART1和UART2的RX TX FIFO是64！就三个UART还整的不一样，顺便赞一下：RS485模式，使用RTS控制485的换向端，真香！</p><h3 id="坑七：NuLink-VS-JLink"><a href="#坑七：NuLink-VS-JLink" class="headerlink" title="坑七：NuLink VS JLink"></a>坑七：<del>NuLink</del> VS <strong>JLink</strong></h3><p>忍受了这么久的NULink，现在终于可以用JLink来欢快的仿真下载调试NUC505了，爽的不要不要的，实现方式很简单，就是在<strong>JLinkDevices.xml</strong>中添加上NUC505的型号就可以了，如下：</p><pre><code>&lt;Device&gt;    &lt;ChipInfo Vendor=&quot;Nuvoton&quot; Name=&quot;NUC505YO13Y&quot; WorkRAMAddr=&quot;0x20000000&quot; WorkRAMSize=&quot;0x00020000&quot; Core=&quot;JLINK_CORE_CORTEX_M4&quot; Aliases=&quot;NUC505DL13Y; NUC505DS13Y&quot;/&gt;    &lt;FlashBankInfo Name=&quot;SPI Flash&quot; BaseAddr=&quot;0x00000000&quot; MaxSize=&quot;0x00200000&quot; Loader=&quot;Devices/Nuvoton/NUC505_SPIFLASH.FLM&quot; LoaderType=&quot;FLASH_ALGO_TYPE_OPEN&quot; /&gt;&lt;/Device&gt;</code></pre><p>然后从keil目录下找到NUC505_SPIFLASH.FLM拷贝到 .\SEGGER\JLink\Devices\Nuvoton目录下即可，就能成功的读到芯片的ID。剩下的跟普通的仿真调试一样了。</p><p>顺便记一下解决仿真时弹出Verification 的ERROR:</p><p><img src="../../../../medias/boardPic/2020/debugError.png" alt="Verification of application image failed."></p><p>先看下下面的 “Download to flash” 是否√了。</p><p><img src="../../../../medias/boardPic/2020/checkDownloadFlash.png" alt="checkDownloadFlash."></p>]]></content>
      
      
      <categories>
          
          <category> ARM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NUC505 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyStm32 - MiniFlasher</title>
      <link href="/2020/02/09/F072MiniFlasher/"/>
      <url>/2020/02/09/F072MiniFlasher/</url>
      
        <content type="html"><![CDATA[<p>使用STM32F072做了一个离线下载器，麻雀虽小然五脏俱全:</p><ul><li>MCU + 8/16 MB SPI Flasher.</li><li>0.96寸 128*64 OLED.</li><li>锂电池充放电管理.</li><li>一键开关机.</li><li>蜂鸣器指示（烧录完成后有提示音）.</li><li>穿上了衣服，有透明外壳.</li></ul><h3 id="Picture"><a href="#Picture" class="headerlink" title="Picture"></a>Picture</h3><p><img src="https://s2.ax1x.com/2020/02/10/14Grmn.jpg" alt="Stm32F072 MiniFlasher"></p><h3 id="离线烧录"><a href="#离线烧录" class="headerlink" title="离线烧录"></a>离线烧录</h3><p>参考移植了DAPLink的代码，烧写速度还是很快的。</p><p>通过MOS管控制对外供电，这样可以在烧写时打开供电，烧录完成后断开供电，可以热插拔了<del>~</del></p><h3 id="SPI-FLash-LittleFS"><a href="#SPI-FLash-LittleFS" class="headerlink" title="SPI FLash - LittleFS"></a>SPI FLash - LittleFS</h3><p>对这个文件系统还是很期待的，好在现在有了<strong>LittleFS Explorer (LFSE) for Windows</strong>工具 ，可以一试。</p><h3 id="GUI"><a href="#GUI" class="headerlink" title="GUI"></a>GUI</h3><p>哪有什么GUI啊，128 * 64 / 8，内存中做了个对应显存，然后全靠画点操作了，速度还是非常非常的快的，加了一个进度条用于烧写进度指示。</p><p>按键支持短按、长按，对于PWR键支持长按关机。</p><p>等有时间了再整理代码吧<del>~</del></p>]]></content>
      
      
      <categories>
          
          <category> STM32 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM32 </tag>
            
            <tag> STM32F072 </tag>
            
            <tag> Flasher </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
